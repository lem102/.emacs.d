* Built-in settings
** default frame size on startup
#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p)
      (setq initial-frame-alist
            '(
              (tool-bar-lines . 0)
              (width . 116)
              (fullscreen . fullheight)
              (left . 0)
              (top . 0))))
#+END_SRC
** move by logical lines
#+BEGIN_SRC emacs-lisp
  (setq line-move-visual t)
#+END_SRC
** Use ls implemented in elisp to have consistent behaviour across platforms
#+BEGIN_SRC emacs-lisp
  (setq ls-lisp-use-insert-directory-program nil)
  (setq ls-lisp-dirs-first t)
#+END_SRC
** Read more data from process
#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC
** Inhibit Startup Message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
** Reduce lag
#+BEGIN_SRC emacs-lisp
  (setq auto-window-vscroll nil)
  (setq redisplay-dont-pause t)
#+END_SRC
** Stop the bell ringing all the time
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
** Prevent the view of the screen jumping to the middle when scrolling out of the view.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
** subword-mode
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :diminish
    :hook (prog-mode . subword-mode))
#+END_SRC

** Make typing delete/overwrite region
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Turn on bracket match highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

** Stop emacs creating backups~
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

** Stop emacs creating #autosaves#
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

** Stop emacs from creating .#lock file links
#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

** Backups don't destroy original file's creation date
#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

** Y/n instead of yes/no
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Expert mode for ibuffer
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC
** Add lisp folder to load path
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/")
#+END_SRC
** Save minibuffer history (useful for compile)
#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
#+END_SRC
** Startup time
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Setting right windows key to act as super key
#+BEGIN_SRC emacs-lisp
  (setq w32-pass-rwindow-to-system nil
		w32-rwindow-modifier 'super)
#+END_SRC

** Setting app key to act as hyper key
#+BEGIN_SRC emacs-lisp
  (setq w32-pass-apps-to-system nil)
  (setq w32-apps-modifier 'hyper)
#+END_SRC
** Tabs
#+BEGIN_SRC emacs-lisp
  ;; use spaces to indent
  (setq-default indent-tabs-mode nil)
  ;; set default tab char's display width to 4 spaces
  (setq-default tab-width 4)
  ;; make tab key call indent command or insert tab character, depending on cursor position
  (setq-default tab-always-indent t)
#+END_SRC
* Personal Functions
#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defun jacob-quit-popup-window ()
    (interactive)
    (let ((loop-list (window-list))
          (window-not-found t))
      (while (and loop-list window-not-found)
        (let* ((window (car loop-list))
               (mode (jacob-buffer-mode (window-buffer window))))
          (if (or (eq mode 'help-mode)
                  (eq mode 'compilation-mode)
                  (eq mode 'special-mode))
              (progn
                (quit-window :window window)
                (setq window-found nil))))
        (setq loop-list (cdr loop-list)))))

  (defun jacob-buffer-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string
       major-mode))

  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

  (defun jacob-org-src-block ()
    "Replacement for C-c ' in both \"org-mode\" and when editing code blocks within \"org-mode\"."
    (interactive)
    (if (bound-and-true-p org-src-mode)
        (org-edit-src-exit)
      (if (equal major-mode 'org-mode)
          (org-edit-special))))

  (defun jacob-recompile-packages ()
    "Recompile all packages."
    (interactive)
    (byte-recompile-directory package-user-dir nil 'force))

  (defun jacob-split-window-below-select-new ()
    "Splits current window vertically, then switch to new window."
    (interactive)
    (split-window-below)
    (other-window 1))


  (defun jacob-split-window-right-select-new ()
    "Splits current window horizontally, then switch to new window."
    (interactive)
    (split-window-right)
    (other-window 1))
#+END_SRC

* Xah Fly Keys
#+BEGIN_SRC emacs-lisp
  (use-package xah-fly-keys
    :ensure t

    :demand

    :init
    (setq xah-fly-use-control-key nil)

    ;; This is a keyboard macro that enters insert mode, presses a backspace, then returns to command mode.
    ;; It's purpose is so I can bind "D" in command mode to whatever backspace does in any given buffer.
    (fset 'backspace
          [?f backspace home])

    (fset 'enter
          [return])

    (defun jacob-xah-command-binds ()
      "Set custom keys for xah-fly-keys keybindings."
      (interactive)
      (define-key xah-fly-key-map (kbd "a") 'counsel-M-x)
      (define-key xah-fly-key-map (kbd "s") 'enter)
      (define-key xah-fly-key-map (kbd "8") 'er/expand-region)
      (define-key xah-fly-key-map (kbd "4") 'jacob-split-window-below-select-new)
      ;; 1 can be rebound, is bound to a inferior version of expand region
      (define-key xah-fly-key-map (kbd "2") 'jacob-quit-popup-window)) 

    :config
    (load-file (expand-file-name "~/.emacs.d/myLisp/jacob-xah-modified-commands.el"))

    (define-prefix-command 'jacob-config-keymap)
    (xah-fly-keys-set-layout "qwerty")
    (xah-fly-keys 1)

    (add-hook 'xah-fly-command-mode-activate-hook 'jacob-xah-command-binds)
    (jacob-xah-command-binds) ;; call it on startup so binds are set without calling xah-fly-command-mode-activate first.

    (add-hook 'dired-mode-hook 'xah-fly-keys-off)
    (add-hook 'eww-mode-hook 'xah-fly-keys-off)
    (add-hook 'ibuffer-mode-hook 'xah-fly-keys-off)
    (add-hook 'custom-mode-hook 'xah-fly-keys-off)

    (key-chord-define xah-fly-key-map "fd" 'xah-fly-command-mode-activate)

    :bind
    (:map jacob-config-keymap
          ("r" . config-reload)
          ("R" . restart-emacs)
          ("e" . config-visit)
          ("c" . jacob-org-src-block)
          ("p" . jacob-recompile-packages)
          ("t" . jacob-long-time-toggle))
    (:map xah-fly-e-keymap
          ("k". jacob-xah-insert-paren)
          ("l". jacob-xah-insert-square-bracket)
          ("j". jacob-xah-insert-brace)
          ("u". jacob-xah-insert-ascii-double-quote)
          ("i". jacob-xah-insert-ascii-single-quote)
          ("m" . xah-insert-hyphen)
          ("," . xah-insert-low-line)
          ("." . jacob-insert-equals)
          ("/" . jacob-insert-plus)
          ("z" . jacob-insert-apostrophe)
          ("x" . jacob-insert-at)
          ("c" . jacob-insert-hash)
          ("d" . backspace)
          ("v" . jacob-insert-tilde))
    (:map xah-fly-dot-keymap
          ("c" . jacob-config-keymap))
    (:map xah-fly-leader-key-map
          ("4" . jacob-split-window-right-select-new))
    (:map xah-fly-w-keymap
          ("n" . eval-and-replace)))
#+END_SRC
* Language Server Protocol & Debug Adapter Protocol
Language Server Protocol is an excellent way to get autocompletion, documentation
and linting for many programming languages within emacs. Therefore this
will eventually be quite a busy section.
** Base lsp-mode
*** lsp-mode
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-mode
     :ensure t
     :hook
     ((java-mode python-mode) . lsp)
     (lsp-mode . lsp-enable-which-key-integration)
     :commands lsp
     :init
     (setq lsp-completion-enable-additional-text-edit nil)
     (setq lsp-prefer-capf nil)
     (setq lsp-prefer-flymake nil)
     :config
     (define-key xah-fly-dot-keymap (kbd "l") lsp-command-map))
 #+END_SRC

*** lsp-ui
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-ui
     :ensure t
     :commands lsp-ui-mode)
 #+END_SRC

*** lsp-ivy
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-ivy
     :ensure t
     :commands lsp-ivy-workspace-symbol)
 #+END_SRC
** Base dsp-mode
#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :ensure t
    :hook java-mode
    :config
    (use-package dap-java)
    (dap-mode 1)
    (dap-ui-mode 1)
    (dap-tooltip-mode 1)
    (tooltip-mode 1)
    (dap-ui-controls-mode 1))
#+END_SRC

** Language Specific
*** lsp-java
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-java
     :ensure t)
 #+END_SRC
*** lsp-python-ms
#+BEGIN_SRC emacs-lisp
  (use-package lsp-python-ms
    :ensure t
    :init (setq lsp-python-ms-auto-install-server t))
#+END_SRC
* Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :config
    (defun jacob-teardown-xah-for-wdired ()
      (interactive)
      (wdired-finish-edit)
      (define-key xah-fly-leader-key-map (kbd ";") 'save-buffer)
      (xah-fly-keys-off))

    (defun jacob-setup-xah-for-wdired ()
      (interactive)
      (xah-fly-keys)
      (define-key xah-fly-leader-key-map (kbd ";") 'jacob-teardown-xah-for-wdired))

    (add-hook 'wdired-mode-hook 'jacob-setup-xah-for-wdired)

    (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
    (define-key dired-mode-map (kbd "^")(lambda () (interactive)(find-alternate-file "..")))
    (setq dired-dwim-target t)

    :bind
    (:map dired-mode-map
          ("," . switch-window)
          ("SPC" . xah-fly-leader-key-map)
          ("p" . dired-maybe-insert-subdir)
          ("i" . dired-previous-line)
          ("k" . dired-next-line)
          ("n" . isearch-forward)
          ("f" . dired-toggle-read-only)
          ("q" . xah-close-current-buffer)))
#+END_SRC
* Major Mode Packages
** bnf-mode
#+BEGIN_SRC emacs-lisp
  (use-package bnf-mode
    :ensure t)
#+END_SRC
** Org
 #+BEGIN_SRC emacs-lisp
   (use-package org
     :mode ("\\.org\\'" . org-mode)
     :config
     (add-to-list 'org-structure-template-alist
                '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")))
 #+END_SRC

** yaml-Mode
 #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode
     :ensure t
     :defer t
     :mode ("\\.yml\\'" . yaml-mode))
 #+END_SRC

** c-mode
*** tab width
 #+BEGIN_SRC emacs-lisp
   (setq-default c-basic-offset 4)
 #+END_SRC

** csharp-mode
 #+BEGIN_SRC emacs-lisp
   (use-package csharp-mode
     :ensure t
     :defer t
     :config
     (defun my-csharp-mode-setup ()
       (setq c-syntactic-indentation t)
       (c-set-style "ellemtel")
       (setq c-basic-offset 4)
       (load-file "~/.emacs.d/myLisp/namespace.el"))
     :hook
     (csharp-mode . my-csharp-mode-setup)
     :mode
     ("\\.cs\\$" . csharp-mode))
 #+END_SRC

** web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t

    :preface
    (defun jacob-web-mode-config ()
      (interactive)
      (setq-local electric-pair-pairs '((?\" . ?\") (?\< . ?\>)))
      (yas-activate-extra-mode 'html-mode))

    :config
    (setq web-mode-engines-alist
                  '(("razor"	. "\\.cshtml\\'")))
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)

    :hook (web-mode . jacob-web-mode-config)

    :mode (("\\.html?\\'" . web-mode)
           ("\\.cshtml\\'" . web-mode)
           ("\\.css\\'" . web-mode)))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode ("\\.json\\$" . json-mode))
#+END_SRC

** clojure-mode
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :mode ("\\.clj\\$" . clojure-mode))
#+END_SRC
* Minor Mode Packages
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer 2
    :config
    (global-flycheck-mode))
#+END_SRC

** beacon
 #+BEGIN_SRC emacs-lisp
   (use-package beacon
     :ensure t
     :demand
     :diminish
     :config
     (setq beacon-color "#f2777a")
     (beacon-mode 1))
 #+END_SRC

** which-key
 #+BEGIN_SRC emacs-lisp
   (use-package which-key
	 :ensure t
     :defer 2
	 :diminish
	 :config
	 (which-key-mode))
 #+END_SRC

** company
 #+BEGIN_SRC emacs-lisp
   (use-package company
     :ensure t
     :defer t
     :diminish
     :hook ((emacs-lisp-mode csharp-mode java-mode) . company-mode)
     :config
     (setq company-idle-delay 0.5)
     (setq company-minimum-prefix-length 3))
 #+END_SRC

** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer 2
    :diminish
    :config
    (projectile-mode t)
    (define-key xah-fly-dot-keymap (kbd "p") projectile-command-map)
    (setq projectile-completion-system 'ivy))
#+END_SRC
** dimmer
#+BEGIN_SRC emacs-lisp
  (use-package dimmer
	:ensure t
    :defer 5
	:config
	(dimmer-mode))
#+END_SRC

** omnisharp
#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
     :ensure t
     :defer t
     :after company
     :hook (csharp-mode . omnisharp-mode)
     :bind
     (:map jacob-omnisharp-keymap
           ("u" . omnisharp-fix-usings)
           ("U" . omnisharp-find-usages)
           ("i" . omnisharp-find-implementations)
           ("d" . omnisharp-go-to-definition)
           ("r" . omnisharp-rename)
           ("a" . omnisharp-run-code-action-refactoring)
           ("o" . omnisharp-start-omnisharp-server)
           ("O" . omnisharp-stop-server))
     :config
     (define-prefix-command 'jacob-omnisharp-keymap)
     (define-key xah-fly-dot-keymap (kbd "o") jacob-omnisharp-keymap)
     (add-hook 'omnisharp-mode-hook (lambda ()
                                      (add-to-list (make-local-variable 'company-backends)
                                                   '(company-omnisharp))))
     (setq omnisharp-company-ignore-case nil)
     (setq omnisharp-server-executable-path "D:\\Programming\\OmniSharp\\omnisharp-roslyn\\bin\\Debug\\OmniSharp.Stdio.Driver\\net472\\OmniSharp.exe"))
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t

    :hook
    (((csharp-mode web-mode python-mode java-mode) . yas-minor-mode))
    
    :config
    (yas-reload-all))
#+END_SRC

** key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :defer 1

    :config
    (key-chord-mode 1))
#+END_SRC

** cider
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :diminish
    :ensure t
    :mode ("\\.clj\\$" . clojure-mode))
#+END_SRC

* Non-mode Packages
** avy
 #+BEGIN_SRC emacs-lisp
   (use-package avy
     :ensure t
     :defer 0.1
     :config
     (setq avy-keys (number-sequence ?a ?z))
     (setq avy-all-windows t)
     (setq avy-orders-alist
           '((avy-goto-char-timer . avy-order-closest)
             (avy-goto-end-of-line . avy-order-closest)))
     (key-chord-define xah-fly-key-map "fj" 'avy-goto-word-or-subword-1)
     (key-chord-define xah-fly-key-map "f;" 'avy-goto-end-of-line))
 #+END_SRC
** minibuffer-line
#+BEGIN_SRC emacs-lisp
  (use-package minibuffer-line
    :ensure t
    :init
    (minibuffer-line-mode)
    :config
    (load "~/.emacs.d/myLisp/jacob-long-time")

    (set-face-attribute 'minibuffer-line nil :foreground "#ffffff" :background "#002451")

    (setq-default minibuffer-line-format (list
                                  ;; date
                                  '(:eval (concat (format-time-string "%A the %e")
                                                  (jacob-day-suffix (string-to-number (format-time-string "%e")))
                                                  (format-time-string " of %B %Y, ")))
                                  ;; time
                                  '(:eval (concat "at "
                                                  (jacob-long-time (string-to-number (format-time-string "%H")) (string-to-number (format-time-string "%M")))))))
    (face-remap-reset-base 'minibuffer-line)
    (minibuffer-line--update))
#+END_SRC
** restart-emacs
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
	:ensure t
	:defer t)
#+END_SRC

** smex
 #+BEGIN_SRC emacs-lisp
   (use-package smex
     :ensure t
     :config (smex-initialize)
     :bind
     ("M-x" . smex))
 #+END_SRC

** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
	:ensure t
	:defer t
	:config
	(diminish 'subword-mode)
	(diminish 'org-src-mode)
	(diminish 'eldoc-mode))
#+END_SRC

** switch-window
 #+BEGIN_SRC emacs-lisp
   (use-package switch-window
	 :ensure t
	 :defer t
	 :config
	 (setq switch-window-input-style 'minibuffer)
	 (setq switch-window-threshold 2)
	 (setq switch-window-multiple-frames t)
	 (setq switch-window-shortcut-style 'qwerty)
	 (setq switch-window-qwerty-shortcuts
		   '("q" "w" "e" "r" "a" "s" "d" "f" "z" "x" "c" "v"))
	 :bind
	 ([remap xah-next-window-or-frame] . switch-window))
 #+END_SRC

** ivy and friends
*** ivy
 #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :ensure t
     :diminish
     :defer 0.1

     :bind
     (:map xah-fly-leader-key-map
           ("v" . counsel-yank-pop))

     :config
     (setq ivy-initial-inputs-alist nil)
     (setq enable-recursive-minibuffers t)
     (ivy-mode 1))
 #+END_SRC

*** swiper
 #+BEGIN_SRC emacs-lisp
   (use-package swiper
     :ensure t
     :after ivy
     :bind
     (:map xah-fly-dot-keymap
           ("s" . swiper)))
 #+END_SRC

*** counsel
 #+BEGIN_SRC emacs-lisp
   (use-package counsel
     :ensure t
     :diminish
     :after ivy
  
     :config (counsel-mode)
     :bind
     (:map xah-fly-c-keymap
           ("e" . counsel-find-file)))
 #+END_SRC

** multiple-cursors
 #+BEGIN_SRC emacs-lisp
   (use-package multiple-cursors
	 :ensure t
	 :bind
	 (:map xah-fly-dot-keymap
		   ("m" . jacob-multiple-cursors-keymap)
	 :map jacob-multiple-cursors-keymap
		   ("l" . mc/edit-lines)
		   (">" . mc/mark-next-like-this)
		   ("<" . mc/mark-previous-like-this)
		   ("a" . mc/mark-all-like-this))
	 :init
	 (define-prefix-command 'jacob-multiple-cursors-keymap))
 #+END_SRC

** expand-region
 #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :ensure t
  
     :config
     (setq expand-region-contract-fast-key "9"))
 #+END_SRC

** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t

    :config
    (setq shell-pop-autocd-to-working-dir nil)
    (setq shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda nil (eshell)))))
    (setq shell-pop-universal-key "<H-return>")
    (setq shell-pop-window-position "bottom")
    (setq shell-pop-window-size 50)

    (defun jacob-shell-pop-eshell ()
      (interactive)
      (let ((shell-pop-shell-type '("eshell" "*eshell*" (lambda () (eshell))))
            (shell-pop-term-shell "eshell"))
        (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
        (call-interactively 'shell-pop)))

    (defun jacob-shell-pop-shell ()
      (interactive)
      (let ((shell-file-name "C:/Windows/System32/Cmd.exe")
            (shell-pop-shell-type '("shell" "*shell*" (lambda () (shell))))
            (shell-pop-term-shell "shell"))
        (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
        (call-interactively 'shell-pop)))

    :bind
    (:map xah-fly-n-keymap
          ("d" . jacob-shell-pop-eshell)
          ("f" . jacob-shell-pop-shell)))
#+END_SRC
** eshell-up
#+BEGIN_SRC emacs-lisp
  (use-package eshell-up
	:ensure t)
#+END_SRC

** langtool
#+BEGIN_SRC emacs-lisp
  (use-package langtool
	;; :ensure t
	:defer t
	:config
	(setq langtool-language-tool-jar
		  "/home/lem/Documents/LanguageTool-4.8/languagetool-commandline.jar"))
#+END_SRC

* Appearance
** Theme (sanityinc-tomorrow)
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t)
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp
  (setq-default mode-line-format (list
                                  ;; saved, readonly
                                  "%*"
                                  ;; major mode
                                  "%m: "
                                  ;; buffer name
                                  "%b "
                                  ;; position of point
                                  "(%l,%c) "))
#+END_SRC
** Get rid of toolbar
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
#+END_SRC

** Get rid of menubar
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
#+END_SRC

** Get rid of scrollbar
#+BEGIN_SRC emacs-lisp
  (scroll-bar-mode -1)
#+END_SRC
** Font Setup
#+BEGIN_SRC emacs-lisp
  (when (member "DejaVu Sans Mono" (font-family-list))
	  (add-to-list 'initial-frame-alist '(font . "DejaVu Sans Mono-10"))
	  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-10")))
#+END_SRC

