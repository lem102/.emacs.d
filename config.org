* Use-Package
#+BEGIN_SRC emacs-lisp
  ;; Make sure use package is available.
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  ;; Configure use-package prior to loading it.
  (eval-and-compile
    (setq use-package-always-ensure nil)
    (setq use-package-always-defer nil)
    (setq use-package-always-demand nil)
    (setq use-package-enable-imenu-support t)
    ;; use real name of hook instead of shorter version.
    (setq use-package-hook-name-suffix nil))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

* Appearance
** Disable GUI components
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    :config
    (setq use-file-dialog nil)
    (setq use-dialog-box t)
    (setq inhibit-startup-message t)
    :bind
    (("C-z" . nil)
     ("C-c C-z" . nil)
     ("C-h h" . nil)))
#+END_SRC
** diminish
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure
    :after use-package)
#+END_SRC
** Theme
*** manoj-dark
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :disabled
    :config
    (load-theme 'manoj-dark t))
#+END_SRC
*** sanityinc-tomorrow-blue
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :disabled
    :defer 0.1
    :config
    (load-theme 'sanityinc-tomorrow-blue t))
#+END_SRC
** Modeline
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (setq-default mode-line-format (list
                                    ;; saved, readonly
                                    "%*"
                                    ;; major mode
                                    "%m: "
                                    ;; buffer name
                                    "%b "
                                    ;; position of point
                                    "(%l,%c) ")))
#+END_SRC
** Fonts
#+BEGIN_SRC emacs-lisp
  (use-package frame
    :config
    (cond
     ((string-equal (system-name) "DESKTOP-F00R5R1")
      (when (member "Ac437 IBM CGA" (font-family-list))
        (add-to-list 'initial-frame-alist '(font . "Ac437 IBM CGA"))
        (add-to-list 'default-frame-alist '(font . "Ac437 IBM CGA"))))
     ((string-equal system-type "windows-nt")
      (when (member "Courier New" (font-family-list))
        (add-to-list 'initial-frame-alist '(font . "Courier New-13:weight=bold"))
        (add-to-list 'default-frame-alist '(font . "Courier New-13:weight=bold"))))))
#+END_SRC
** beacon
 #+BEGIN_SRC emacs-lisp
   (use-package beacon
     :ensure t
     :demand
     :diminish
     :config
     (beacon-mode 1))
 #+END_SRC
** dimmer
#+BEGIN_SRC emacs-lisp
  (use-package dimmer
	:ensure t
    :defer 5
	:config
	(dimmer-mode))
#+END_SRC
** default frame size on startup
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (if (display-graphic-p)
        (setq initial-frame-alist
              '(
                (tool-bar-lines . 0)
                (width . 116)
                (fullscreen . fullheight)
                (left . 0)
                (top . 0)))))
#+END_SRC
* Built-in settings
** dabbrev
#+BEGIN_SRC emacs-lisp
  (use-package dabbrev
    :config
    :bind (("M-/" . dabbrev-expand)
           ("C-M-/" . dabbrev-completion)))
#+END_SRC
** put custom stuff in custom.el
#+BEGIN_SRC emacs-lisp
  (use-package cus-edit
    :config
    (defvar prot/custom-file "~/.emacs.d/custom.el")
    (setq custom-file prot/custom-file)
    (defun prot/cus-edit ()
      (let ((custom-file prot/custom-file))
        (unless (file-exists-p custom-file)
          (make-empty-file custom-file))
        (load-file custom-file))))
#+END_SRC
** always rebuild init
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (defun prot/rebuild-emacs-init ()
      (let ((config-el "~/.emacs.d/config.el")
            (config-org "~/.emacs.d/config.org"))
        (when config-el
          (delete-file config-el))
        (org-babel-tangle-file config-org config-el)))
    :hook ((kill-emacs-hook . prot/rebuild-emacs-init)))
#+END_SRC
** prevent emacs from disabling commands.
#+BEGIN_SRC emacs-lisp
  (setq disabled-command-function nil)
#+END_SRC
** move by logical lines
#+BEGIN_SRC emacs-lisp
  (setq line-move-visual t)
#+END_SRC
** Use ls implemented in elisp to have consistent behaviour across platforms
#+BEGIN_SRC emacs-lisp
  (setq ls-lisp-use-insert-directory-program nil)
  (setq ls-lisp-dirs-first t)
#+END_SRC
** Read more data from process
#+BEGIN_SRC emacs-lisp
  (setq read-process-output-max (* 1024 1024))
#+END_SRC
** Reduce lag
#+BEGIN_SRC emacs-lisp
  (setq auto-window-vscroll nil)
  (setq redisplay-dont-pause t)
#+END_SRC
** Stop the bell ringing all the time
#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC
** Prevent the view of the screen jumping to the middle when scrolling out of the view.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC
** subword-mode
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :diminish
    :hook (prog-mode-hook . subword-mode))
#+END_SRC

** Make typing delete/overwrite region
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Turn on bracket match highlight
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Prevent emacs from creating debris when editing files
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    (setq make-backup-files nil)
    (setq auto-save-default nil)
    (setq create-lockfiles nil))
#+END_SRC
** Backups don't destroy original file's creation date
#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t)
#+END_SRC

** Y/n instead of yes/no
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Expert mode for ibuffer
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC
** Add lisp folder to load path
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/")
#+END_SRC
** Save minibuffer history (useful for compile)
#+BEGIN_SRC emacs-lisp
  (use-package savehist
    :config
    (setq savehist-file "~/.emacs.d/savehist")
    (setq history-length 1000)
    (setq history-delete-duplicates t)
    (setq savehist-save-minibuffer-history t)
    :hook (after-init-hook . savehist-mode))
#+END_SRC
** Save cursor position in files
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config
    (setq save-place-file "~/.emacs.d/saveplace")
    (setq save-place-forget-unreadable-files t)
    (save-place-mode 1))
#+END_SRC
** Startup time
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC
** Setting right windows key to act as super key
#+BEGIN_SRC emacs-lisp
  (setq w32-pass-rwindow-to-system nil
		w32-rwindow-modifier 'super)
#+END_SRC

** Setting app key to act as hyper key
#+BEGIN_SRC emacs-lisp
  (setq w32-pass-apps-to-system nil)
  (setq w32-apps-modifier 'hyper)
#+END_SRC
** Tabs
#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :config
    ;; use spaces to indent
    (setq-default indent-tabs-mode nil)
    ;; set default tab char's display width to 4 spaces
    (setq-default tab-width 4)
    ;; make tab key call indent command or insert tab character, depending on cursor position
    (setq-default tab-always-indent 'complete))
#+END_SRC
* Personal Functions
#+BEGIN_SRC emacs-lisp
  (defun jacob-original-find-file ()
    "Uses the original file-file mechanism. 
  Useful for dealing with files on other servers.
  (at least on Microsoft Windows)"
    (interactive)
    (let ((completing-read-function 'completing-read-default))
      (call-interactively 'find-file)))

  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defun jacob-quit-popup-window ()
    (interactive)
    (let ((loop-list (window-list))
          (window-not-found t))
      (while (and loop-list window-not-found)
        (let* ((window (car loop-list))
               (mode (jacob-buffer-mode (window-buffer window))))
          (if (or (eq mode 'help-mode)
                  (eq mode 'compilation-mode)
                  (eq mode 'special-mode))
              (progn
                (quit-window :window window)
                (setq window-found nil))))
        (setq loop-list (cdr loop-list)))))

  (defun jacob-buffer-mode (buffer-or-string)
    "Returns the major mode associated with a buffer."
    (with-current-buffer buffer-or-string
       major-mode))

  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))

  (defun jacob-org-src-block ()
    "Replacement for C-c ' in both \"org-mode\" and when editing code blocks within \"org-mode\"."
    (interactive)
    (if (bound-and-true-p org-src-mode)
        (org-edit-src-exit)
      (if (equal major-mode 'org-mode)
          (org-edit-special))))

  (defun jacob-recompile-packages ()
    "Recompile all packages."
    (interactive)
    (byte-recompile-directory package-user-dir nil 'force))

  (defun jacob-split-window-below-select-new ()
    "Splits current window vertically, then switch to new window."
    (interactive)
    (split-window-below)
    (other-window 1))


  (defun jacob-split-window-right-select-new ()
    "Splits current window horizontally, then switch to new window."
    (interactive)
    (split-window-right)
    (other-window 1))

  (load-file (expand-file-name "~/.emacs.d/myLisp/jacob-long-time.el"))

  (defun jacob-display-time ()
    "Display the current date and time in the echo area."
    (interactive)
    (message (concat (format-time-string "%A the %e")
                     (jacob-day-suffix (string-to-number (format-time-string "%e")))
                     (format-time-string " of %B %Y, ")
                     "at "
                     (jacob-long-time (string-to-number (format-time-string "%H"))
                                      (string-to-number (format-time-string "%M"))))))
#+END_SRC

* Xah Fly Keys
#+BEGIN_SRC emacs-lisp
  (use-package xah-fly-keys
    :ensure t

    :demand

    :init
    (setq xah-fly-use-control-key nil)

    ;; This is a keyboard macro that enters insert mode, presses a backspace, then returns to command mode.
    ;; It's purpose is so I can bind "D" in command mode to whatever backspace does in any given buffer.
    (fset 'backspace
          [?f backspace home])

    (fset 'enter
          [return])

    (defun jacob-xah-command-binds ()
      "Set custom keys for xah-fly-keys keybindings."
      (interactive)
      (define-key xah-fly-key-map (kbd "a") 'counsel-M-x)
      (define-key xah-fly-key-map (kbd "s") 'enter)
      (define-key xah-fly-key-map (kbd "8") 'er/expand-region)
      (define-key xah-fly-key-map (kbd "4") 'jacob-split-window-below-select-new)
      ;; 1 can be rebound, is bound to a inferior version of expand region
      (define-key xah-fly-key-map (kbd "2") 'jacob-quit-popup-window))

    :config
    (load-file (expand-file-name "~/.emacs.d/myLisp/jacob-xah-modified-commands.el"))

    (define-prefix-command 'jacob-config-keymap)
    (xah-fly-keys-set-layout "qwerty")
    (xah-fly-keys 1)

    (add-hook 'xah-fly-command-mode-activate-hook 'jacob-xah-command-binds)
    (jacob-xah-command-binds) ;; call it on startup so binds are set without calling xah-fly-command-mode-activate first.

    (add-hook 'dired-mode-hook 'xah-fly-keys-off)
    (add-hook 'eww-mode-hook 'xah-fly-keys-off)
    (add-hook 'ibuffer-mode-hook 'xah-fly-keys-off)
    (add-hook 'custom-mode-hook 'xah-fly-keys-off)

    (key-chord-define xah-fly-key-map "fd" 'xah-fly-command-mode-activate)

    :bind
    (:map jacob-config-keymap
          ("r" . config-reload)
          ("R" . restart-emacs)
          ("e" . config-visit)
          ("c" . jacob-org-src-block)
          ("p" . jacob-recompile-packages)
          ("t" . jacob-display-time))
    (:map xah-fly-e-keymap
          ("k". jacob-xah-insert-paren)
          ("l". jacob-xah-insert-square-bracket)
          ("j". jacob-xah-insert-brace)
          ("u". jacob-xah-insert-ascii-double-quote)
          ("i". jacob-xah-insert-ascii-single-quote)
          ("m" . xah-insert-hyphen)
          ("," . xah-insert-low-line)
          ("." . jacob-insert-equals)
          ("/" . jacob-insert-plus)
          ("z" . jacob-insert-apostrophe)
          ("x" . jacob-insert-at)
          ("c" . jacob-insert-hash)
          ("d" . backspace)
          ("v" . jacob-insert-tilde))
    (:map xah-fly-dot-keymap
          ("c" . jacob-config-keymap))
    (:map xah-fly-leader-key-map
          ("4" . jacob-split-window-right-select-new))
    (:map xah-fly-w-keymap
          ("n" . eval-and-replace)))
#+END_SRC
* Language Server Protocol & Debug Adapter Protocol
Language Server Protocol is an excellent way to get autocompletion, documentation
and linting for many programming languages within emacs. Therefore this
will eventually be quite a busy section.
** Base lsp-mode
*** lsp-mode
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-mode
     :ensure t
     :hook
     ((java-mode-hook python-mode-hook) . lsp)
     (lsp-mode-hook . lsp-enable-which-key-integration)
     :commands lsp
     :init
     (setq lsp-completion-enable-additional-text-edit nil)
     (setq lsp-prefer-capf nil)
     (setq lsp-prefer-flymake nil)
     :config
     (define-key xah-fly-dot-keymap (kbd "l") lsp-command-map))
 #+END_SRC

*** lsp-ui
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-ui
     :ensure t
     :commands lsp-ui-mode)
 #+END_SRC

*** lsp-ivy
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-ivy
     :ensure t
     :commands lsp-ivy-workspace-symbol)
 #+END_SRC
** Base dsp-mode
#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :ensure t
    :hook java-mode-hook
    :config
    (use-package dap-java)
    (dap-mode 1)
    (dap-ui-mode 1)
    (dap-tooltip-mode 1)
    (tooltip-mode 1)
    (dap-ui-controls-mode 1))
#+END_SRC

** Language Specific
*** lsp-java
 #+BEGIN_SRC emacs-lisp
   (use-package lsp-java
     :ensure t)
 #+END_SRC
*** lsp-python-ms
#+BEGIN_SRC emacs-lisp
  (use-package lsp-python-ms
    :ensure t
    :init (setq lsp-python-ms-auto-install-server t))
#+END_SRC
* Dired
#+BEGIN_SRC emacs-lisp
  (use-package dired
    :config
    (defun jacob-teardown-xah-for-wdired ()
      (interactive)
      (wdired-finish-edit)
      (define-key xah-fly-leader-key-map (kbd ";") 'save-buffer)
      (xah-fly-keys-off))

    (defun jacob-setup-xah-for-wdired ()
      (interactive)
      (xah-fly-keys)
      (define-key xah-fly-leader-key-map (kbd ";") 'jacob-teardown-xah-for-wdired))

    (add-hook 'wdired-mode-hook 'jacob-setup-xah-for-wdired)

    (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
    (define-key dired-mode-map (kbd "^")(lambda () (interactive)(find-alternate-file "..")))
    (setq dired-dwim-target t)

    :bind
    (:map dired-mode-map
          ("," . switch-window)
          ("SPC" . xah-fly-leader-key-map)
          ("p" . dired-maybe-insert-subdir)
          ("i" . dired-previous-line)
          ("k" . dired-next-line)
          ("n" . isearch-forward)
          ("f" . dired-toggle-read-only)
          ("q" . xah-close-current-buffer)))
#+END_SRC
* Major Mode Packages
** emacs-lisp-mode
#+BEGIN_SRC emacs-lisp
  (use-package elisp-mode
    :config
    (defun contrib/completing-read-in-region (start end collection &optional predicate)
      "Prompt for completion of region in the minibuffer if non-unique.
    Use as a value for `completion-in-region-function'."
      (if (and (minibufferp) (not (string= (minibuffer-prompt) "Eval: ")))
          (completion--in-region start end collection predicate)
        (let* ((initial (buffer-substring-no-properties start end))
               (limit (car (completion-boundaries initial collection predicate "")))
               (all (completion-all-completions initial collection predicate
                                                (length initial)))
               (completion (cond
                            ((atom all) nil)
                            ((and (consp all) (atom (cdr all)))
                             (concat (substring initial 0 limit) (car all)))
                            (t (completing-read
                                "Completion: " collection predicate t initial)))))
          (if (null completion)
              (progn (message "No completion") nil)
            (delete-region start end)
            (insert completion)
            t))))

    (setq completion-in-region-function #'contrib/completing-read-in-region))
#+END_SRC
** bnf-mode
#+BEGIN_SRC emacs-lisp
  (use-package bnf-mode
    :ensure t)
#+END_SRC
** Org
 #+BEGIN_SRC emacs-lisp
   (use-package org
     :mode ("\\.org\\'" . org-mode)
     :config
     (add-to-list 'org-structure-template-alist
                  '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")))
 #+END_SRC

** yaml-Mode
 #+BEGIN_SRC emacs-lisp
   (use-package yaml-mode
     :ensure t
     :defer t
     :mode ("\\.yml\\'" . yaml-mode))
 #+END_SRC

** c-mode
*** tab width
 #+BEGIN_SRC emacs-lisp
   (setq-default c-basic-offset 4)
 #+END_SRC

** csharp-mode
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :ensure t
    :defer t
    :config
    (defun my-csharp-mode-setup ()
      (setq c-syntactic-indentation t)
      (c-set-style "ellemtel")
      (setq c-basic-offset 4)
      (load-file "~/.emacs.d/myLisp/namespace.el")
      (company-mode t)
      (yas-minor-mode t)
      (omnisharp-mode t))
    :hook
    (csharp-mode-hook . my-csharp-mode-setup)
    :mode
    ("\\.cs\\$" . csharp-mode))
#+END_SRC

** web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t

    :preface
    (defun jacob-web-mode-config ()
      (interactive)
      (setq-local electric-pair-pairs '((?\" . ?\") (?\< . ?\>)))
      (yas-activate-extra-mode 'html-mode))

    :config
    (setq web-mode-engines-alist
                  '(("razor"	. "\\.cshtml\\'")))
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)

    :hook (web-mode-hook . jacob-web-mode-config)

    :mode (("\\.html?\\'" . web-mode)
           ("\\.cshtml\\'" . web-mode)
           ("\\.css\\'" . web-mode)))
#+END_SRC
** json-mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode ("\\.json\\$" . json-mode))
#+END_SRC

** clojure-mode
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :mode ("\\.clj\\$" . clojure-mode))
#+END_SRC
* Minor Mode Packages
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :defer 2
    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (global-flycheck-mode))
#+END_SRC
** which-key
 #+BEGIN_SRC emacs-lisp
   (use-package which-key
	 :ensure t
     :defer 2
	 :diminish
	 :config
	 (which-key-mode))
 #+END_SRC

** company
 #+BEGIN_SRC emacs-lisp
   (use-package company
     :ensure t
     :defer t
     :diminish
     :hook ((java-mode-hook) . company-mode)
     :config
     (setq company-idle-delay 0.5)
     (setq company-minimum-prefix-length 3))
 #+END_SRC

** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer 2
    :diminish
    :config
    (projectile-mode t)
    (define-key xah-fly-dot-keymap (kbd "p") projectile-command-map)
    (setq projectile-completion-system 'ivy))
#+END_SRC
** omnisharp
#+BEGIN_SRC emacs-lisp
  ;; FIXME: if company mode is not started before csharp mode is entered, omnisharp mode will not activate
  (use-package omnisharp
    :ensure t
    :defer t
    :bind
    (:map jacob-omnisharp-keymap
          ("u" . omnisharp-fix-usings)
          ("U" . omnisharp-find-usages)
          ("i" . omnisharp-find-implementations)
          ("d" . omnisharp-go-to-definition)
          ("r" . omnisharp-rename)
          ("a" . omnisharp-run-code-action-refactoring)
          ("o" . omnisharp-start-omnisharp-server)
          ("O" . omnisharp-stop-server))
    :config
    ;; at this point, company mode is enabled.
    (define-prefix-command 'jacob-omnisharp-keymap)
    (define-key xah-fly-dot-keymap (kbd "o") jacob-omnisharp-keymap)
    (add-hook 'omnisharp-mode-hook (lambda ()
                                     (add-to-list (make-local-variable 'company-backends)
                                                  '(company-omnisharp))))
    (setq omnisharp-company-ignore-case nil)
    (setq omnisharp-server-executable-path "D:\\Programming\\OmniSharp\\omnisharp-roslyn\\bin\\Debug\\OmniSharp.Stdio.Driver\\net472\\OmniSharp.exe")

    (defun jacob-csharp-indent-or-complete ()
      (interactive)
      (if (region-active-p)
          (c-indent-line-or-region :region (region-bounds))
        (let ((old-point (point)))
          (c-indent-line-or-region)
          (if (eq old-point (point))
              (call-interactively 'counsel-company)))))

    (define-key csharp-mode-map (kbd "<tab>") 'jacob-csharp-indent-or-complete))
#+END_SRC

** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t

    :hook
    (((web-mode-hook python-mode-hook java-mode-hook) . yas-minor-mode))

    :config
    (yas-reload-all))
#+END_SRC

** key-chord
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :defer 1

    :config
    (key-chord-mode 1))
#+END_SRC

** cider
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :diminish
    :ensure t
    :mode ("\\.clj\\$" . clojure-mode))
#+END_SRC
* Non-mode Packages
** try
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC
** avy
 #+BEGIN_SRC emacs-lisp
   (use-package avy
     :ensure t
     :defer 0.1
     :config
     (setq avy-keys (number-sequence ?a ?z))
     (setq avy-all-windows t)
     (setq avy-orders-alist
           '((avy-goto-char-timer . avy-order-closest)
             (avy-goto-end-of-line . avy-order-closest)))
     (key-chord-define xah-fly-key-map "fj" 'avy-goto-word-or-subword-1)
     (key-chord-define xah-fly-key-map "f;" 'avy-goto-end-of-line))
 #+END_SRC
** restart-emacs
#+BEGIN_SRC emacs-lisp
  (use-package restart-emacs
    :ensure t
    :defer t)
#+END_SRC

** smex
 #+BEGIN_SRC emacs-lisp
   (use-package smex
     :ensure t
     :config (smex-initialize)
     :bind
     ("M-x" . smex))
 #+END_SRC
** switch-window
 #+BEGIN_SRC emacs-lisp
   (use-package switch-window
	 :ensure t
	 :defer t
	 :config
	 (setq switch-window-input-style 'minibuffer)
	 (setq switch-window-threshold 2)
	 (setq switch-window-multiple-frames t)
	 (setq switch-window-shortcut-style 'qwerty)
	 (setq switch-window-qwerty-shortcuts
		   '("q" "w" "e" "r" "a" "s" "d" "f" "z" "x" "c" "v"))
	 :bind
	 ([remap xah-next-window-or-frame] . switch-window))
 #+END_SRC

** ivy and friends
*** ivy
 #+BEGIN_SRC emacs-lisp
   (use-package ivy
     :ensure t
     :diminish
     :defer 0.1
     :config
     (setq ivy-initial-inputs-alist nil)
     (setq enable-recursive-minibuffers t)
     (setq completing-read-function 'ivy-completing-read)
     :bind
     (:map xah-fly-c-keymap
           ("e" . counsel-find-file))
     (:map xah-fly-dot-keymap
           ("s" . swiper))
     (:map xah-fly-h-keymap
           ("j" . counsel-describe-function)
           ("l" . counsel-describe-variable))
     (:map xah-fly-leader-key-map
           ("v" . counsel-yank-pop)
           ("f" . ivy-switch-buffer)))
#+END_SRC

*** swiper
 #+BEGIN_SRC emacs-lisp
   (use-package swiper
     :ensure t
     :after ivy)
 #+END_SRC

*** counsel
 #+BEGIN_SRC emacs-lisp
   (use-package counsel
     :ensure t
     :diminish
     :after ivy)
 #+END_SRC
 
** multiple-cursors
 #+BEGIN_SRC emacs-lisp
   (use-package multiple-cursors
	 :ensure t
	 :bind
	 (:map xah-fly-dot-keymap
		   ("m" . jacob-multiple-cursors-keymap)
	 :map jacob-multiple-cursors-keymap
		   ("l" . mc/edit-lines)
		   (">" . mc/mark-next-like-this)
		   ("<" . mc/mark-previous-like-this)
		   ("a" . mc/mark-all-like-this))
	 :init
	 (define-prefix-command 'jacob-multiple-cursors-keymap))
 #+END_SRC

** expand-region
 #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :ensure t
  
     :config
     (setq expand-region-contract-fast-key "9"))
 #+END_SRC

** shell-pop
#+BEGIN_SRC emacs-lisp
  (use-package shell-pop
    :ensure t

    :config
    (setq shell-pop-autocd-to-working-dir nil)
    (setq shell-pop-shell-type (quote ("eshell" "*eshell*" (lambda nil (eshell)))))
    (setq shell-pop-universal-key "<H-return>")
    (setq shell-pop-window-position "bottom")
    (setq shell-pop-window-size 50)

    (defun jacob-shell-pop-eshell ()
      (interactive)
      (let ((shell-pop-shell-type '("eshell" "*eshell*" (lambda () (eshell))))
            (shell-pop-term-shell "eshell"))
        (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
        (call-interactively 'shell-pop)))

    (defun jacob-shell-pop-shell ()
      (interactive)
      (let ((shell-file-name "C:/Windows/System32/Cmd.exe")
            (shell-pop-shell-type '("shell" "*shell*" (lambda () (shell))))
            (shell-pop-term-shell "shell"))
        (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
        (call-interactively 'shell-pop)))

    :bind
    (:map xah-fly-n-keymap
          ("d" . jacob-shell-pop-eshell)
          ("f" . jacob-shell-pop-shell)))
#+END_SRC
** eshell-up
#+BEGIN_SRC emacs-lisp
  (use-package eshell-up
	:ensure t)
#+END_SRC

** langtool
#+BEGIN_SRC emacs-lisp
  (use-package langtool
	;; :ensure t
	:defer t
	:config
	(setq langtool-language-tool-jar
		  "/home/lem/Documents/LanguageTool-4.8/languagetool-commandline.jar"))
#+END_SRC
