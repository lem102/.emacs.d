;;; Quickstart file to activate all packages at startup  -*- lexical-binding:t -*-
;; ¡¡ This file is autogenerated by `package-quickstart-refresh', DO NOT EDIT !!

(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/yaml-mode-20201109.1026/yaml-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/yaml-mode-20201109.1026/yaml-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/yaml-mode-20201109.1026/yaml-mode-autoloads.el") (car load-path))))



(let ((loads (get 'yaml 'custom-loads))) (if (member '"yaml-mode" loads) nil (put 'yaml 'custom-loads (cons '"yaml-mode" loads))))

(autoload 'yaml-mode "yaml-mode" "\
Simple mode to edit YAML.

\\{yaml-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yaml-mode" '("yaml-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/xah-fly-keys-20210216.2215/xah-fly-keys-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/xah-fly-keys-20210216.2215/xah-fly-keys-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/xah-fly-keys-20210216.2215/xah-fly-keys-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "xah-fly-keys" '("xah-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/vertico-0.21/vertico-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/vertico-0.21/vertico-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/vertico-0.21/vertico-autoloads.el") (car load-path))))



(defvar vertico-mode nil "\
Non-nil if Vertico mode is enabled.
See the `vertico-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-mode'.")

(custom-autoload 'vertico-mode "vertico" nil)

(autoload 'vertico-mode "vertico" "\
VERTical Interactive COmpletion.

If called interactively, enable Vertico mode if ARG is positive,
and disable it if ARG is zero or negative.  If called from Lisp,
also enable the mode if ARG is omitted or nil, and toggle it if
ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico" '("vertico-")))



(defvar vertico-buffer-mode nil "\
Non-nil if Vertico-Buffer mode is enabled.
See the `vertico-buffer-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-buffer-mode'.")

(custom-autoload 'vertico-buffer-mode "vertico-buffer" nil)

(autoload 'vertico-buffer-mode "vertico-buffer" "\
Display Vertico in a buffer instead of the minibuffer.

If called interactively, enable Vertico-Buffer mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-buffer" '("vertico-buffer-")))



(autoload 'vertico-directory-enter "vertico-directory" "\
Enter directory or exit completion with current candidate." t nil)

(autoload 'vertico-directory-up "vertico-directory" "\
Delete N directories before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-delete-char "vertico-directory" "\
Delete N directories or chars before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-delete-word "vertico-directory" "\
Delete N directories or words before point.

\(fn &optional N)" t nil)

(autoload 'vertico-directory-tidy "vertico-directory" "\
Tidy shadowed file name, see `rfn-eshadow-overlay'." nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-directory" '("vertico-directory--completing-file-p")))



(defvar vertico-flat-mode nil "\
Non-nil if Vertico-Flat mode is enabled.
See the `vertico-flat-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-flat-mode'.")

(custom-autoload 'vertico-flat-mode "vertico-flat" nil)

(autoload 'vertico-flat-mode "vertico-flat" "\
Flat, horizontal display for Vertico.

If called interactively, enable Vertico-Flat mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-flat" '("vertico-flat-")))



(defvar vertico-grid-mode nil "\
Non-nil if Vertico-Grid mode is enabled.
See the `vertico-grid-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-grid-mode'.")

(custom-autoload 'vertico-grid-mode "vertico-grid" nil)

(autoload 'vertico-grid-mode "vertico-grid" "\
Grid display for Vertico.

If called interactively, enable Vertico-Grid mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-grid" '("vertico-grid-")))



(defvar vertico-indexed-mode nil "\
Non-nil if Vertico-Indexed mode is enabled.
See the `vertico-indexed-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-indexed-mode'.")

(custom-autoload 'vertico-indexed-mode "vertico-indexed" nil)

(autoload 'vertico-indexed-mode "vertico-indexed" "\
Prefix candidates with indices.

If called interactively, enable Vertico-Indexed mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-indexed" '("vertico-indexed--")))



(defvar vertico-mouse-mode nil "\
Non-nil if Vertico-Mouse mode is enabled.
See the `vertico-mouse-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-mouse-mode'.")

(custom-autoload 'vertico-mouse-mode "vertico-mouse" nil)

(autoload 'vertico-mouse-mode "vertico-mouse" "\
Mouse support for Vertico.

If called interactively, enable Vertico-Mouse mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-mouse" '("vertico-mouse--")))



(defvar vertico-multiform-mode nil "\
Non-nil if Vertico-Multiform mode is enabled.
See the `vertico-multiform-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-multiform-mode'.")

(custom-autoload 'vertico-multiform-mode "vertico-multiform" nil)

(autoload 'vertico-multiform-mode "vertico-multiform" "\
Configure Vertico in various forms per command.

If called interactively, enable Vertico-Multiform mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-multiform" '("vertico-multiform-")))



(autoload 'vertico-quick-jump "vertico-quick" "\
Jump to candidate using quick keys." t nil)

(autoload 'vertico-quick-exit "vertico-quick" "\
Exit with candidate using quick keys." t nil)

(autoload 'vertico-quick-insert "vertico-quick" "\
Insert candidate using quick keys." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-quick" '("vertico-quick")))



(autoload 'vertico-repeat "vertico-repeat" "\
Repeat last Vertico completion session." t nil)

(autoload 'vertico-repeat-save "vertico-repeat" "\
Save Vertico status for `vertico-repeat'.
This function must be registered as `minibuffer-setup-hook'." nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-repeat" '("vertico-repeat--")))



(defvar vertico-reverse-mode nil "\
Non-nil if Vertico-Reverse mode is enabled.
See the `vertico-reverse-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-reverse-mode'.")

(custom-autoload 'vertico-reverse-mode "vertico-reverse" nil)

(autoload 'vertico-reverse-mode "vertico-reverse" "\
Reverse the Vertico display.

If called interactively, enable Vertico-Reverse mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-reverse" '("vertico-reverse-")))



(defvar vertico-unobtrusive-mode nil "\
Non-nil if Vertico-Unobtrusive mode is enabled.
See the `vertico-unobtrusive-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `vertico-unobtrusive-mode'.")

(custom-autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" nil)

(autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" "\
Unobtrusive display for Vertico.

If called interactively, enable Vertico-Unobtrusive mode if ARG
is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "vertico-unobtrusive" '("vertico-unobtrusive--orig-count")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/typescript-mode-20201002.1109/typescript-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/typescript-mode-20201002.1109/typescript-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/typescript-mode-20201002.1109/typescript-mode-autoloads.el") (car load-path))))


(put 'typescript-indent-level 'safe-local-variable #'integerp)

(autoload 'typescript-mode "typescript-mode" "\
Major mode for editing typescript.

Key bindings:

\\{typescript-mode-map}

\(fn)" t nil)

(eval-after-load 'folding '(when (fboundp 'folding-add-to-marks-list) (folding-add-to-marks-list 'typescript-mode "// {{{" "// }}}")))

(add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typescript-mode" '("typescript-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "typescript-mode-test-utilities" '("font-lock-test" "get-face-at" "test-with-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tsc-20220212.1632/tsc-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tsc-20220212.1632/tsc-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/tsc-20220212.1632/tsc-autoloads.el") (car load-path))))



(register-definition-prefixes "tsc" '("tsc-"))



(register-definition-prefixes "tsc-dyn-get" '("tsc-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-20220212.1632/tree-sitter-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-20220212.1632/tree-sitter-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-20220212.1632/tree-sitter-autoloads.el") (car load-path))))



(autoload 'tree-sitter-mode "tree-sitter" "\
Minor mode that keeps an up-to-date syntax tree using incremental parsing.

This is a minor mode.  If called interactively, toggle the
`tree-sitter mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `tree-sitter-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-tree-sitter-mode "tree-sitter" "\
Turn on `tree-sitter-mode' in a buffer, if possible." nil nil)

(put 'global-tree-sitter-mode 'globalized-minor-mode t)

(defvar global-tree-sitter-mode nil "\
Non-nil if Global Tree-Sitter mode is enabled.
See the `global-tree-sitter-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-tree-sitter-mode'.")

(custom-autoload 'global-tree-sitter-mode "tree-sitter" nil)

(autoload 'global-tree-sitter-mode "tree-sitter" "\
Toggle Tree-Sitter mode in all buffers.
With prefix ARG, enable Global Tree-Sitter mode if ARG is positive;
otherwise, disable it.

If called from Lisp, toggle the mode if ARG is `toggle'.
Enable the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

Tree-Sitter mode is enabled in all buffers where
`turn-on-tree-sitter-mode' would do it.

See `tree-sitter-mode' for more information on Tree-Sitter mode.

\(fn &optional ARG)" t nil)

(define-obsolete-function-alias 'tree-sitter-node-at-point 'tree-sitter-node-at-pos "2021-08-30")

(autoload 'tree-sitter-node-at-pos "tree-sitter" "\
Return the smallest syntax node of type NODE-TYPE at POS.
NODE-TYPE may be a symbol, corresponding to a named syntax node; a string,
corresponding to an anonymous node, or a keyword, holding a special value. For
the special value `:named', return the smallest named node at POS. For the
special value `:anonymous', return the smallest anonymous node at POS. IF POS is
nil, POS defaults to the point. Unless IGNORE-INVALID-TYPE is non-nil, signal an
error when a specified named NODE-TYPE does not exist in the current grammar.
Whenever NODE-TYPE is non-nil (other than `:named'), it is possible for the
function to return nil.

\(fn &optional NODE-TYPE POS IGNORE-INVALID-TYPE)" nil nil)

(register-definition-prefixes "tree-sitter" '("tree-sitter-"))



(register-definition-prefixes "tree-sitter-cli" '("tree-sitter-cli-"))



(autoload 'tree-sitter-debug-mode "tree-sitter-debug" "\
Toggle syntax tree debugging for the current buffer.
This mode displays the syntax tree in another buffer, and keeps it up-to-date.

This is a minor mode.  If called interactively, toggle the
`Tree-Sitter-Debug mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `tree-sitter-debug-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(autoload 'tree-sitter-debug-query "tree-sitter-debug" "\
Execute query PATTERNS against the current syntax tree and return captures.

If the optional arg MATCHES is non-nil, matches (from `tsc-query-matches') are
returned instead of captures (from `tsc-query-captures').

If the optional arg TAG-ASSIGNER is non-nil, it is passed to `tsc-make-query' to
assign custom tags to capture names.

This function is primarily useful for debugging purpose. Other packages should
build queries and cursors once, then reuse them.

\(fn PATTERNS &optional MATCHES TAG-ASSIGNER)" nil nil)

(register-definition-prefixes "tree-sitter-debug" '("tree-sitter-debug-"))



(autoload 'tree-sitter-save-excursion "tree-sitter-extras" "\
Save the current location within the syntax tree; execute BODY; restore it.

If the original location cannot be restored due to the syntax tree changing too
much, this macro behaves like `save-excursion', unless
`tree-sitter-save-excursion-try-hard' is non-nil, in which case it tries to get
as close as possible to the original location.

After the location is restored, the buffer text is scrolled so that point stays
at roughly the same vertical screen position. If `pixel-scroll' is available and
`tree-sitter-save-excursion-pixelwise' is non-nil, pixelwise scrolling is used
instead, to make this restoration exact.

\(fn &rest BODY)" nil t)

(function-put 'tree-sitter-save-excursion 'lisp-indent-function '0)

(register-definition-prefixes "tree-sitter-extras" '("tree-sitter-"))



(autoload 'tree-sitter-hl-add-patterns "tree-sitter-hl" "\
Add custom syntax highlighting PATTERNS.
If LANG-SYMBOL is non-nil, it identifies the language that PATTERNS should be
applied to. If LANG-SYMBOL is nil, PATTERNS are applied to the current buffer,
and are prioritized over language-specific patterns. Either way, PATTERNS are
prioritized over `tree-sitter-hl-default-patterns'.

This function should be used by minor modes and configuration code. Major modes
should set `tree-sitter-hl-default-patterns' instead.

\(fn LANG-SYMBOL PATTERNS)" nil nil)

(function-put 'tree-sitter-hl-add-patterns 'lisp-indent-function '1)

(autoload 'tree-sitter-hl-mode "tree-sitter-hl" "\
Toggle syntax highlighting based on Tree-sitter's syntax tree.
If `tree-sitter-hl-default-patterns' is nil, turning on this mode does nothing,
and does not interfere with `font-lock-mode'.

This is a minor mode.  If called interactively, toggle the
`Tree-Sitter-Hl mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `tree-sitter-hl-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

Enabling this automatically enables `tree-sitter-mode' in the buffer.

To enable this automatically whenever `tree-sitter-mode' is enabled:

 (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

\(fn &optional ARG)" t nil)

(register-definition-prefixes "tree-sitter-hl" '("tree-sitter-hl-"))



(autoload 'tree-sitter-require "tree-sitter-load" "\
Return the language object loaded and registered under the name LANG-SYMBOL.
If the language has not been loaded yet, load it with `tree-sitter-load'.

FILE should be the base name (without extension) of the native shared library
that exports the language as the native symbol NATIVE-SYMBOL-NAME.

If FILE is nil, the base name is assumed to be LANG-SYMBOL's name.

If NATIVE-SYMBOL-NAME is nil, the name of the exported native symbol is assumed
to be LANG-SYMBOL's name, prefixed with \"tree_sitter_\".

\(fn LANG-SYMBOL &optional FILE NATIVE-SYMBOL-NAME)" nil nil)

(register-definition-prefixes "tree-sitter-load" '("tree-sitter-l"))



(autoload 'tree-sitter-query-builder "tree-sitter-query" "\
Provide means for developers to write and test tree-sitter queries.

The buffer on focus when the command is called is set as the target buffer." t nil)

(register-definition-prefixes "tree-sitter-query" '("tree-sitter-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-langs-20220508.636/tree-sitter-langs-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-langs-20220508.636/tree-sitter-langs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-langs-20220508.636/tree-sitter-langs-autoloads.el") (car load-path))))



(autoload 'tree-sitter-langs--init-load-path "tree-sitter-langs" "\
Add the directory containing compiled grammars to `tree-sitter-load-path'.

\(fn &rest ARGS)" nil nil)

(advice-add 'tree-sitter-load :before #'tree-sitter-langs--init-load-path)

(autoload 'tree-sitter-langs--init-major-mode-alist "tree-sitter-langs" "\
Link known major modes to languages provided by the bundle.

\(fn &rest ARGS)" nil nil)

(advice-add 'tree-sitter--setup :before #'tree-sitter-langs--init-major-mode-alist)

(autoload 'tree-sitter-langs--set-hl-default-patterns "tree-sitter-langs" "\
Use syntax highlighting patterns provided by `tree-sitter-langs'.

\(fn &rest ARGS)" nil nil)

(advice-add 'tree-sitter-hl--setup :before #'tree-sitter-langs--set-hl-default-patterns)

(register-definition-prefixes "tree-sitter-langs" '("tree-sitter-langs-"))



(autoload 'tree-sitter-langs-install-grammars "tree-sitter-langs-build" "\
Download and install the specified VERSION of the language grammar bundle.
If VERSION or OS is not specified, use the default of
`tree-sitter-langs--bundle-version' and `tree-sitter-langs--os'.

This installs the grammar bundle even if the same version was already installed,
unless SKIP-IF-INSTALLED is non-nil.

The download bundle file is deleted after installation, unless KEEP-BUNDLE is
non-nil.

\(fn &optional SKIP-IF-INSTALLED VERSION OS KEEP-BUNDLE)" t nil)

(register-definition-prefixes "tree-sitter-langs-build" '("tree-sitter-langs-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-indent-20220411.1439/tree-sitter-indent-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-indent-20220411.1439/tree-sitter-indent-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/tree-sitter-indent-20220411.1439/tree-sitter-indent-autoloads.el") (car load-path))))



(autoload 'tree-sitter-indent-line "tree-sitter-indent" "\
Use Tree-sitter as backend to indent current line." nil nil)

(autoload 'tree-sitter-indent-mode "tree-sitter-indent" "\
Use Tree-sitter as backend for indenting buffer.

This is a minor mode.  If called interactively, toggle the
`Tree-Sitter-Indent mode' mode.  If the prefix argument is
positive, enable the mode, and if it is zero or negative, disable
the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `tree-sitter-indent-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "tree-sitter-indent" '("tree-sitter-indent-"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/spinner-1.7.4/spinner-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/spinner-1.7.4/spinner-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/spinner-1.7.4/spinner-autoloads.el") (car load-path))))



(autoload 'spinner-create "spinner" "\
Create a spinner of the given TYPE.
The possible TYPEs are described in `spinner--type-to-frames'.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

If BUFFER-LOCAL is non-nil, the spinner will be automatically
deactivated if the buffer is killed.  If BUFFER-LOCAL is a
buffer, use that instead of current buffer.

When started, in order to function properly, the spinner runs a
timer which periodically calls `force-mode-line-update' in the
current buffer.  If BUFFER-LOCAL was set at creation time, then
`force-mode-line-update' is called in that buffer instead.  When
the spinner is stopped, the timer is deactivated.

DELAY, if given, is the number of seconds to wait after starting
the spinner before actually displaying it. It is safe to cancel
the spinner before this time, in which case it won't display at
all.

\(fn &optional TYPE BUFFER-LOCAL FPS DELAY)" nil nil)

(autoload 'spinner-start "spinner" "\
Start a mode-line spinner of given TYPE-OR-OBJECT.
If TYPE-OR-OBJECT is an object created with `make-spinner',
simply activate it.  This method is designed for minor modes, so
they can use the spinner as part of their lighter by doing:
    '(:eval (spinner-print THE-SPINNER))
To stop this spinner, call `spinner-stop' on it.

If TYPE-OR-OBJECT is anything else, a buffer-local spinner is
created with this type, and it is displayed in the
`mode-line-process' of the buffer it was created it.  Both
TYPE-OR-OBJECT and FPS are passed to `make-spinner' (which see).
To stop this spinner, call `spinner-stop' in the same buffer.

Either way, the return value is a function which can be called
anywhere to stop this spinner.  You can also call `spinner-stop'
in the same buffer where the spinner was created.

FPS, if given, is the number of desired frames per second.
Default is `spinner-frames-per-second'.

DELAY, if given, is the number of seconds to wait until actually
displaying the spinner. It is safe to cancel the spinner before
this time, in which case it won't display at all.

\(fn &optional TYPE-OR-OBJECT FPS DELAY)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "spinner" '("spinner-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/sml-mode-6.10/sml-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/sml-mode-6.10/sml-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/sml-mode-6.10/sml-mode-autoloads.el") (car load-path))))



(defalias 'run-sml 'sml-run)

(autoload 'sml-run "sml-mode" "\
Run the program CMD with given arguments ARG.
The command is run in buffer *CMD* using mode `inferior-sml-mode'.
If the buffer already exists and has a running process, then
just go to this buffer.

If a prefix argument is used, the user is also prompted for a HOST
on which to run CMD using `remote-shell-program'.

\(Type \\[describe-mode] in the process's buffer for a list of commands.)

\(fn CMD ARG &optional HOST)" t nil)

(add-to-list 'auto-mode-alist '("\\.s\\(ml\\|ig\\)\\'" . sml-mode))

(autoload 'sml-mode "sml-mode" "\
Major mode for editing Standard ML code.
This mode runs `sml-mode-hook' just before exiting.
See also (info \"(sml-mode)Top\").

\(fn)" t nil)

(add-to-list 'completion-ignored-extensions ".cm/")

(add-to-list 'auto-mode-alist '("\\.cm\\'" . sml-cm-mode))

(autoload 'sml-cm-mode "sml-mode" "\
Major mode for SML/NJ's Compilation Manager configuration files.

\(fn)" t nil)

(autoload 'sml-lex-mode "sml-mode" "\
Major Mode for editing ML-Lex files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.grm\\'" . sml-yacc-mode))

(autoload 'sml-yacc-mode "sml-mode" "\
Major Mode for editing ML-Yacc files.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sml-mode" '("font-lock-" "inferior-sml-" "sml-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/sesman-20210901.1134/sesman-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/sesman-20210901.1134/sesman-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/sesman-20210901.1134/sesman-autoloads.el") (car load-path))))



(autoload 'sesman-start "sesman" "\
Start a Sesman session." t nil)

(autoload 'sesman-restart "sesman" "\
Restart sesman session.
When WHICH is nil, restart the current session; when a single universal
argument or 'linked, restart all linked sessions; when a double universal
argument, t or 'all, restart all sessions. For programmatic use, WHICH can also
be a session or a name of the session, in which case that session is restarted.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-quit "sesman" "\
Terminate a Sesman session.
When WHICH is nil, kill only the current session; when a single universal
argument or 'linked, kill all linked sessions; when a double universal argument,
t or 'all, kill all sessions. For programmatic use, WHICH can also be a session
or a name of the session, in which case that session is killed.

\(fn &optional WHICH)" t nil)

(autoload 'sesman-info "sesman" "\
Display info for all current sessions (`sesman-current-sessions').
In the resulting minibuffer display linked sessions are numbered and the
other (friendly) sessions are not. When ALL is non-nil, show info for all
sessions.

\(fn &optional ALL)" t nil)

(autoload 'sesman-link-with-buffer "sesman" "\
Ask for SESSION and link with BUFFER.
BUFFER defaults to current buffer. On universal argument, or if BUFFER is 'ask,
ask for buffer.

\(fn &optional BUFFER SESSION)" t nil)

(autoload 'sesman-link-with-directory "sesman" "\
Ask for SESSION and link with DIR.
DIR defaults to `default-directory'. On universal argument, or if DIR is 'ask,
ask for directory.

\(fn &optional DIR SESSION)" t nil)

(autoload 'sesman-link-with-project "sesman" "\
Ask for SESSION and link with PROJECT.
PROJECT defaults to current project. On universal argument, or if PROJECT is
'ask, ask for the project. SESSION defaults to the current session.

\(fn &optional PROJECT SESSION)" t nil)

(autoload 'sesman-link-with-least-specific "sesman" "\
Ask for SESSION and link with the least specific context available.
Normally the least specific context is the project. If not in a project, link
with the `default-directory'. If `default-directory' is nil, link with current
buffer.

\(fn &optional SESSION)" t nil)

(autoload 'sesman-unlink "sesman" "\
Break sesman LINKS.
If LINKS is nil, ask interactively for a link. With a prefix argument break all
links.

\(fn &optional LINKS)" t nil)
 (autoload 'sesman-map "sesman" "Session management prefix keymap." t 'keymap)

(register-definition-prefixes "sesman" '("sesman-"))



(autoload 'sesman-browser "sesman-browser" "\
Display an interactive session browser.
See `sesman-browser-mode' for more details." t nil)

(register-definition-prefixes "sesman-browser" '("sesman-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/s-20210616.619/s-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/s-20210616.619/s-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/s-20210616.619/s-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "s" '("s-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/restclient-20210923.2234/restclient-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/restclient-20210923.2234/restclient-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/restclient-20210923.2234/restclient-autoloads.el") (car load-path))))



(autoload 'restclient-http-send-current "restclient" "\
Sends current request.
Optional argument RAW don't reformat response if t.
Optional argument STAY-IN-WINDOW do not move focus to response buffer if t.

\(fn &optional RAW STAY-IN-WINDOW)" t nil)

(autoload 'restclient-http-send-current-raw "restclient" "\
Sends current request and get raw result (no reformatting or syntax highlight of XML, JSON or images)." t nil)

(autoload 'restclient-http-send-current-stay-in-window "restclient" "\
Send current request and keep focus in request window." t nil)

(autoload 'restclient-mode "restclient" "\
Turn on restclient mode.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "restclient" '("restclient-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/restart-emacs-20201127.1425/restart-emacs-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/restart-emacs-20201127.1425/restart-emacs-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/restart-emacs-20201127.1425/restart-emacs-autoloads.el") (car load-path))))



(autoload 'restart-emacs-handle-command-line-args "restart-emacs" "\
Handle the --restart-emacs-desktop command line argument.

The value of the argument is the desktop file from which the frames should be
restored.  IGNORED are ignored.

\(fn &rest IGNORED)" nil nil)

(add-to-list 'command-switch-alist '("--restart-emacs-desktop" . restart-emacs-handle-command-line-args))

(autoload 'restart-emacs "restart-emacs" "\
Restart Emacs.

When called interactively ARGS is interpreted as follows

- with a single `universal-argument' (`C-u') Emacs is restarted
  with `--debug-init' flag
- with two `universal-argument' (`C-u') Emacs is restarted with
  `-Q' flag
- with three `universal-argument' (`C-u') the user prompted for
  the arguments

When called non-interactively ARGS should be a list of arguments
with which Emacs should be restarted.

\(fn &optional ARGS)" t nil)

(autoload 'restart-emacs-start-new-emacs "restart-emacs" "\
Start a new instance of Emacs.

When called interactively ARGS is interpreted as follows

- with a single `universal-argument' (`C-u') the new Emacs is started
  with `--debug-init' flag
- with two `universal-argument' (`C-u') the new Emacs is started with
  `-Q' flag
- with three `universal-argument' (`C-u') the user prompted for
  the arguments

When called non-interactively ARGS should be a list of arguments
with which the new Emacs should be started.

\(fn &optional ARGS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "restart-emacs" '("restart-emacs-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/pos-tip-20191227.1356/pos-tip-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/pos-tip-20191227.1356/pos-tip-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/pos-tip-20191227.1356/pos-tip-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "pos-tip" '("pos-tip-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/racket-mode-20210831.2045/racket-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/racket-mode-20210831.2045/racket-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/racket-mode-20210831.2045/racket-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-browse-url" '("racket-browse-url")))



(autoload 'racket-bug-report "racket-bug-report" "\
Fill a buffer with data to make a Racket Mode bug report." t nil)



(defvar racket-start-back-end-hook nil "\
Hook run after `racket-start-back-end'.")

(autoload 'racket-start-back-end "racket-cmd" "\
Start the back end process used by Racket Mode.

If the process is already started, this command will stop and restart it.

As the final step, runs the hook `racket-start-back-end-hook'." t nil)

(autoload 'racket-stop-back-end "racket-cmd" "\
Stop the back end process used by Racket Mode.

If the process is not already started, this does nothing." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-cmd" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-collection" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-common" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-complete" '("racket--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-custom" '("defface-racket" "racket-")))



(autoload 'racket--debug-send-definition "racket-debug" "\


\(fn BEG END)" nil nil)

(autoload 'racket--debug-on-break "racket-debug" "\


\(fn RESPONSE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-debug" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-describe" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-doc" '("racket--")))



(add-to-list 'hs-special-modes-alist '(racket-mode "(" ")" ";" nil nil))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-edit" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-eldoc" '("racket--do-eldoc")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-font-lock" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-imenu" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-indent" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-keywords-and-builtins" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-logger" '("racket-")))



(autoload 'racket-mode "racket-mode" "\
Major mode for editing Racket source files.

\\{racket-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.rkt\\'" . racket-mode))

(add-to-list 'auto-mode-alist '("\\.rktd\\'" . racket-mode))

(add-to-list 'auto-mode-alist '("\\.rktl\\'" . racket-mode))

(modify-coding-system-alist 'file "\\.rkt[dl]?\\'" 'utf-8)

(add-to-list 'interpreter-mode-alist '("racket" . racket-mode))

(autoload 'racket-mode-start-faster "racket-mode" "\
Compile Racket Mode's .rkt files for faster startup.

Racket Mode is implemented as an Emacs Lisp \"front end\" that
talks to a Racket process \"back end\". Because Racket Mode is
delivered as an Emacs package instead of a Racket package,
installing it does not do the `raco setup` that is normally done
for Racket packages.

This command will do a `raco make` of Racket Mode's .rkt files,
creating bytecode files in `compiled/` subdirectories. As a
result, when a command must start the Racket process, it will
start somewhat faster.

On many computers, the resulting speed up is negligible, and
might not be worth the complication.

If you run this command, ever, you will need to run it again
after:

- Installing an updated version of Racket Mode. Otherwise, you
  might lose some of the speed-up.

- Installing a new version of Racket and/or changing the value of
  the variable `racket-program'. Otherwise, you might get an
  error message due to the bytecode being different versions.

To revert to compiling on startup, use
`racket-mode-start-slower'. " t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-mode" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-parens" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-ppss" '("racket--ppss-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-profile" '("racket-")))



(autoload 'racket-repl "racket-repl" "\
Show a Racket REPL buffer in some window.

*IMPORTANT*

The main, intended use of Racket Mode's REPL is that you
`find-file' some specific .rkt file, then `racket-run' it. The
REPL will then match that file.

If the REPL isn't running, and you want to start it for no file
in particular? Then you could use this command. But the resulting
REPL will have a minimal \"#lang racket/base\" namespace. You
could enter \"(require racket)\" if you want the equivalent of
\"#lang racket\". You could also \"(require racket/enter)\" if
you want things like \"enter!\". But in some sense you'd be
\"using it wrong\". If you really don't want to use Racket Mode's
REPL as intended, then you might as well use a plain Emacs shell
buffer to run command-line Racket.

\(fn &optional NOSELECT)" t nil)

(autoload 'racket-run "racket-repl" "\
Save the buffer in REPL and run your program.

As well as evaluating the outermost, file module, automatically
runs the submodules specified by the customization variable
`racket-submodules-to-run'.

See also `racket-run-module-at-point', which runs just the
specific module at point.

With \\[universal-argument] uses errortrace for improved stack traces.
Otherwise follows the `racket-error-context' setting.

With \\[universal-argument] \\[universal-argument] instruments
code for step debugging. See `racket-debug-mode' and the variable
`racket-debuggable-files'.

Each run occurs within a Racket custodian. Any prior run's
custodian is shut down, releasing resources like threads and
ports. Each run's evaluation environment is reset to the contents
of the source file. In other words, like Dr Racket, this provides
the benefit that your source file is the \"single source of
truth\". At the same time, the run gives you a REPL inside the
namespace of the module, giving you the ability to explore it
interactively. Any explorations are temporary, unless you also
make them to your source file, they will be lost on the next run.

See also `racket-run-and-switch-to-repl', which is even more like
Dr Racket's Run command because it selects the REPL window after
running.

In the `racket-repl-mode' buffer, output that describes a file
and position is automatically \"linkified\". Examples of such
text include:

- Racket error messages.
- rackunit test failure location messages.
- print representation of path objects.

To visit these locations, move point there and press RET or mouse
click. Or, use the standard `next-error' and `previous-error'
commands.

\(fn &optional PREFIX)" t nil)

(autoload 'racket-run-module-at-point "racket-repl" "\
Save the buffer and run the module at point.

Like `racket-run' but runs the innermost module around point,
which is determined textually by looking for \"module\",
\"module*\", or \"module+\" forms nested to any depth, else
simply the outermost, file module.

\(fn &optional PREFIX)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-repl" '("racket-" "with-racket-repl-buffer")))



(autoload 'racket-repl-buffer-name-shared "racket-repl-buffer-name" "\
All `racket-mode' edit buffers share one `racket-repl-mode' buffer.

A value for the variable `racket-repl-buffer-name-function'." t nil)

(autoload 'racket-repl-buffer-name-unique "racket-repl-buffer-name" "\
Each `racket-mode' edit buffer gets its own `racket-repl-mode' buffer.

A value for the variable `racket-repl-buffer-name-function'." t nil)

(autoload 'racket-repl-buffer-name-project "racket-repl-buffer-name" "\
All `racket-mode' buffers in a project share a `racket-repl-mode' buffer.

A value for the variable `racket-repl-buffer-name-function'.

The \"project\" is determined by `racket-project-root'." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-repl-buffer-name" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-show" '("racket-")))



(autoload 'racket-smart-open-bracket-mode "racket-smart-open" "\
Minor mode to let you always type `[`' to insert `(` or `[` automatically.

If called interactively, enable Racket-Smart-Open-Bracket mode if
ARG is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

Behaves like the \"Automatically adjust opening square brackets\"
feature in Dr. Racket.

By default, inserts a `(`. Inserts a `[` in the following cases:

  - `let`-like bindings -- forms with `let` in the name as well
    as things like `parameterize`, `with-handlers`, and
    `with-syntax`.

  - `case`, `cond`, `match`, `syntax-case`, `syntax-parse`, and
    `syntax-rules` clauses.

  - `for`-like bindings and `for/fold` accumulators.

  - `class` declaration syntax, such as `init` and `inherit`.

When the previous s-expression in a sequence is a compound
expression, uses the same kind of delimiter.

To force insert `[`, use `quoted-insert'.

Combined with `racket-insert-closing' this means that you can
press the unshifted `[` and `]` keys to get whatever delimiters
follow the Racket conventions for these forms. When something
like `electric-pair-mode' or `paredit-mode' is active, you need
not even press `]`.

Tip: When also using `paredit-mode', enable that first so that
the binding for the `[`' key in the map for
`racket-smart-open-bracket-mode' has higher priority. See also
the variable `minor-mode-map-alist'.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-smart-open" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-stepper" '("racket-")))



(autoload 'racket-unicode-input-method-enable "racket-unicode-input-method" "\
Set input method to racket-unicode.

The racket-unicode input method lets you easily type various
Unicode symbols that might be useful when writing Racket code.

To automatically enable the racket-unicode input method in
racket-mode and racket-repl-mode buffers, put the following code
in your Emacs init file:

#+BEGIN_SRC elisp
    (add-hook 'racket-mode-hook #'racket-unicode-input-method-enable)
    (add-hook 'racket-repl-mode-hook #'racket-unicode-input-method-enable)
#+END_SRC

To temporarily enable this input method for a single buffer you
can use \"M-x racket-unicode-input-method-enable\".

Use the standard Emacs key C-\\ to toggle the input method.

When the racket-unicode input method is active, you can for
example type \"All\" and it is immediately replaced with \"∀\". A
few other examples:

| omega     | ω                        |
| x_1       | x₁                       |
| x^1       | x¹                       |
| A         | 𝔸                        |
| test-->>E | test-->>∃ (racket/redex) |
| vdash     | ⊢                        |

To see a table of all key sequences use \"M-x
describe-input-method <RET> racket-unicode\".

If you want to add your own mappings to the \"racket-unicode\"
input method, you may add code like the following example in your
Emacs init file:

#+BEGIN_SRC elisp
    ;; Either (require 'racket-mode) here, or, if you use
    ;; use-package, put the code below in the :config section.
    (with-temp-buffer
      (racket-unicode-input-method-enable)
      (set-input-method \"racket-unicode\")
      (let ((quail-current-package (assoc \"racket-unicode\"
                                          quail-package-alist)))
        (quail-define-rules ((append . t))
                            (\"^o\" [\"ᵒ\"]))))
#+END_SRC

If you don’t like the highlighting of partially matching tokens you
can turn it off by setting `input-method-highlight-flag' to nil." t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-util" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-visit" '("racket--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-wsl" '("racket-")))



(autoload 'racket-xp-mode "racket-xp" "\
A minor mode that analyzes expanded code to explain and explore.

If called interactively, enable Racket-Xp mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

This minor mode is an optional enhancement to `racket-mode' edit
buffers. Like any minor mode, you can turn it on or off for a
specific buffer. If you always want to use it, put the following
code in your Emacs init file:

#+BEGIN_SRC elisp
    (require 'racket-xp)
    (add-hook 'racket-mode-hook #'racket-xp-mode)
#+END_SRC

Note: This mode won't do anything unless/until the Racket Mode
back end is running. It will try to start the back end
automatically. You do /not/ need to `racket-run' the buffer you
are editing.

This mode uses the drracket/check-syntax package to analyze
fully-expanded programs, without needing to evaluate a.k.a.
\"run\" them. The resulting analysis provides information for:

- Visually annotating bindings -- local or imported definitions
  and references to them.

- Visually annotating expressions in a tail position, as well as
  the enclosing expression with respect to which they are in a
  tail position.

- Completion candidates.

- Defintions' source and documentation.

When point is on a definition or use, related items are
highlighted using `racket-xp-def-face' and `racket-xp-use-face'
-- instead of drawing arrows as in Dr Racket. Information is
displayed using the function(s) in the hook variable
`racket-show-functions'; it is also available when hovering the
mouse cursor.

Note: If you find these point-motion features too distracting
and/or slow, in your `racket-xp-mode-hook' you may disable them:

#+BEGIN_SRC elisp
  (require 'racket-xp)
  (add-hook 'racket-xp-mode-hook
            (lambda ()
              (remove-hook 'pre-redisplay-functions
                           #'racket-xp-pre-redisplay
                           t)))
#+END_SRC

The remaining features discussed below will still work.

You may also use commands to navigate among a definition and its
uses, or to rename a local definitions and all its uses:

  - `racket-xp-next-definition'
  - `racket-xp-previous-definition'
  - `racket-xp-next-use'
  - `racket-xp-previous-use'

In the following little example, not only does
drracket/check-syntax distinguish the various \"x\" bindings, it
understands the two different imports of \"define\":

#+BEGIN_SRC racket
  #lang racket/base
  (define x 1)
  x
  (let ([x x])
    (+ x 1))
  (module m typed/racket/base
    (define x 2)
    x)
#+END_SRC

When point is on the opening parenthesis of an expression in tail
position, it is highlighted using the face
`racket-xp-tail-position-face'.

When point is on the opening parenthesis of an enclosing
expression with respect to which one or more expressions are in
tail position, it is highlighted using the face
`racket-xp-tail-target-face'.

Furthermore, when point is on the opening parenthesis of either
kind of expression, all of the immediately related expressions
are also highlighted. Various commands move among them:

  - `racket-xp-tail-up'
  - `racket-xp-tail-down'
  - `racket-xp-tail-next-sibling'
  - `racket-xp-tail-previous-sibling'

The function `racket-xp-complete-at-point' is added to the
variable `completion-at-point-functions'. Note that in this case,
it is not smart about submodules; identifiers are assumed to be
definitions from the file's module or its imports. In addition to
supplying completion candidates, it supports the
\":company-location\" property to inspect the definition of a
candidate and the \":company-doc-buffer\" property to view its
documentation.

When you edit the buffer, existing annotations are retained;
their positions are updated to reflect the edit. Annotations for
new or deleted text are not requested until after
`racket-xp-after-change-refresh-delay' seconds. The request is
made asynchronously so that Emacs will not block -- for
moderately complex source files, it can take some seconds simply
to fully expand them, as well as a little more time for the
drracket/check-syntax analysis. When the results are ready, all
annotations for the buffer are completely refreshed.

You may also set `racket-xp-after-change-refresh-delay' to nil
and use the `racket-xp-annotate' command manually.

The mode line changes to reflect the current status of
annotations, and whether or not you had a syntax error.

If you have one or more syntax errors, `racket-xp-next-error' and
`racket-xp-previous-error' navigate among them. Although most
languages will stop after the first syntax error, some like Typed
Racket will try to collect and report multiple errors.

You may use `xref-find-definitions' \\[xref-find-definitions],
`xref-pop-marker-stack' \\[xref-pop-marker-stack], and
`xref-find-references': `racket-xp-mode' adds a backend to the
variable `xref-backend-functions'. This backend uses information
from the drracket/check-syntax static analysis. Its ability to
find references is limited to the current file; when it finds
none it will try the default xref backend implementation which is
grep-based.

Tip: This mode follows the convention that a minor mode may only
use a prefix key consisting of \"C-c\" followed by a punctuation
key. As a result, `racket-xp-control-c-hash-keymap' is bound to
\"C-c #\" by default. Although you might find this awkward to
type, remember that as an Emacs user, you are free to bind this
map to a more convenient prefix, and/or bind any individual
commands directly to whatever keys you prefer.

\\{racket-xp-mode-map}

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-xp" '("racket-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "racket-xp-complete" '("racket-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/queue-0.2/queue-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/queue-0.2/queue-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/queue-0.2/queue-autoloads.el") (car load-path))))



(defalias 'make-queue 'queue-create "\
Create an empty queue data structure.")

(register-definition-prefixes "queue" '("queue"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/purescript-mode-20210109.244/purescript-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/purescript-mode-20210109.244/purescript-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/purescript-mode-20210109.244/purescript-mode-autoloads.el") (car load-path))))



(autoload 'purescript-align-imports "purescript-align-imports" "\
Align all the imports in the buffer." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-align-imports" '("purescript-align-imports-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-collapse" '("purescript-collapse")))



(autoload 'purescript-ds-create-imenu-index "purescript-decl-scan" "\
Function for finding `imenu' declarations in PureScript mode.
Finds all declarations (classes, variables, imports, instances and
datatypes) in a PureScript file for the `imenu' package." nil nil)

(autoload 'turn-on-purescript-decl-scan "purescript-decl-scan" "\
Unconditionally activate `purescript-decl-scan-mode'." t nil)

(autoload 'purescript-decl-scan-mode "purescript-decl-scan" "\
Toggle PureScript declaration scanning minor mode on or off.
With a prefix argument ARG, enable minor mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.

See also info node `(purescript-mode)purescript-decl-scan-mode' for
more details about this minor mode.

Top-level declarations are scanned and listed in the menu item
\"Declarations\" (if enabled via option
`purescript-decl-scan-add-to-menubar').  Selecting an item from this
menu will take point to the start of the declaration.

\\[beginning-of-defun] and \\[end-of-defun] move forward and backward to the start of a declaration.

This may link with `purescript-doc-mode'.

For non-literate and LaTeX-style literate scripts, we assume the
common convention that top-level declarations start at the first
column.  For Bird-style literate scripts, we assume the common
convention that top-level declarations start at the third column,
ie. after \"> \".

Anything in `font-lock-comment-face' is not considered for a
declaration.  Therefore, using PureScript font locking with comments
coloured in `font-lock-comment-face' improves declaration scanning.

Literate PureScript scripts are supported: If the value of
`purescript-literate' (set automatically by `literate-purescript-mode')
is `bird', a Bird-style literate script is assumed.  If it is nil
or `tex', a non-literate or LaTeX-style literate script is
assumed, respectively.

Invokes `purescript-decl-scan-mode-hook' on activation.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-decl-scan" '("literate-purescript-ds-" "purescript-d")))



(autoload 'purescript-font-lock-choose-keywords "purescript-font-lock" nil nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-font-lock" '("purescript-" "turn-o")))



(autoload 'turn-on-purescript-indent "purescript-indent" "\
Turn on ``intelligent'' PureScript indentation mode." nil nil)

(autoload 'purescript-indent-mode "purescript-indent" "\
``Intelligent'' PureScript indentation mode.
This deals with the layout rule of PureScript.
\\[purescript-indent-cycle] starts the cycle which proposes new
possibilities as long as the TAB key is pressed.  Any other key
or mouse click terminates the cycle and is interpreted except for
RET which merely exits the cycle.
Other special keys are:
    \\[purescript-indent-insert-equal]
      inserts an =
    \\[purescript-indent-insert-guard]
      inserts an |
    \\[purescript-indent-insert-otherwise]
      inserts an | otherwise =
these functions also align the guards and rpurs of the current definition
    \\[purescript-indent-insert-where]
      inserts a where keyword
    \\[purescript-indent-align-guards-and-rpurs]
      aligns the guards and rpurs of the region
    \\[purescript-indent-put-region-in-literate]
      makes the region a piece of literate code in a literate script

Invokes `purescript-indent-hook' if not nil.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-indent" '("purescript-indent-" "turn-off-purescript-indent")))



(autoload 'purescript-indentation-mode "purescript-indentation" "\
PureScript indentation mode that deals with the layout rule.
It rebinds RET, DEL and BACKSPACE, so that indentations can be
set and deleted as if they were real tabs.  It supports
autofill-mode.

If called interactively, enable Purescript-Indentation mode if
ARG is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-purescript-indentation "purescript-indentation" "\
Turn on the purescript-indentation minor mode." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-indentation" '("on-parse-error" "parse-error" "purescript-")))



(autoload 'purescript-version "purescript-mode" "\
Show the `purescript-mode` version in the echo area.
With prefix argument HERE, insert it at point.
When FULL is non-nil, use a verbose version string.
When MESSAGE is non-nil, display a message with the version.

\(fn &optional HERE)" t nil)

(autoload 'purescript-mode-view-news "purescript-mode" "\
Display information on recent changes to purescript-mode." t nil)

(autoload 'purescript-customize "purescript-mode" "\
Browse the purescript customize sub-tree.
This calls 'customize-browse' with purescript as argument and makes
sure all purescript customize definitions have been loaded." t nil)

(defvar purescript-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-c C-.") 'purescript-mode-format-imports) (define-key map [remap delete-indentation] 'purescript-delete-indentation) map) "\
Keymap used in PureScript mode.")

(autoload 'purescript-mode "purescript-mode" "\
Major mode for editing PureScript programs.

See also Info node `(purescript-mode)Getting Started' for more
information about this mode.

\\<purescript-mode-map>
Literate scripts are supported via `literate-purescript-mode'.
The variable `purescript-literate' indicates the style of the script in the
current buffer.  See the documentation on this variable for more details.

Use `purescript-version' to find out what version of PureScript mode you are
currently using.

Additional PureScript mode modules can be hooked in via `purescript-mode-hook';
see documentation for that variable for more details.

\(fn)" t nil)

(autoload 'literate-purescript-mode "purescript-mode" "\
As `purescript-mode' but for literate scripts.

\(fn)" t nil)
(add-to-list 'auto-mode-alist '("\\.purs\\'" . purescript-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-mode" '("purescript-")))



(autoload 'purescript-move-nested "purescript-move-nested" "\
Shift the nested off-side-rule block adjacent to point by COLS columns to the right.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

\(fn COLS)" nil nil)

(autoload 'purescript-move-nested-right "purescript-move-nested" "\
Increase indentation of the following off-side-rule block adjacent to point.

Use a numeric prefix argument to indicate amount of indentation to apply.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

\(fn COLS)" t nil)

(autoload 'purescript-move-nested-left "purescript-move-nested" "\
Decrease indentation of the following off-side-rule block adjacent to point.

Use a numeric prefix argument to indicate amount of indentation to apply.

In Transient Mark mode, if the mark is active, operate on the contents
of the region instead.

\(fn COLS)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-move-nested" '("purescript-")))



(autoload 'purescript-navigate-imports "purescript-navigate-imports" "\
Cycle the PureScript import lines or return to point (with prefix arg).

\(fn &optional RETURN)" t nil)

(autoload 'purescript-navigate-imports-go "purescript-navigate-imports" "\
Go to the first line of a list of consequtive import lines. Cycles." t nil)

(autoload 'purescript-navigate-imports-return "purescript-navigate-imports" "\
Return to the non-import point we were at before going to the module list.
   If we were originally at an import list, we can just cycle through easily." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-navigate-imports" '("purescript-navigate-imports-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-presentation-mode" '("purescript-present")))



(autoload 'purescript-show-replace "purescript-show" "\
Replace the given region containing a Show value with a pretty
  printed collapsible version.

\(fn START END)" nil nil)

(autoload 'purescript-show-parse-and-insert "purescript-show" "\
Parse a `string' containing a Show instance value and insert
  it pretty printed into the current buffer.

\(fn GIVEN)" nil nil)

(autoload 'purescript-show-parse "purescript-show" "\
Parse the given input into a tree.

\(fn GIVEN)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-show" '("purescript-show-" "sexp-show")))



(autoload 'purescript-simple-indent-mode "purescript-simple-indent" "\
Simple PureScript indentation mode that uses simple heuristic.
In this minor mode, `indent-for-tab-command' (bound to <tab> by
default) will move the cursor to the next indent point in the
previous nonblank line, whereas `purescript-simple-indent-backtab'
\(bound to <backtab> by default) will move the cursor the
previous indent point.  An indent point is a non-whitespace
character following whitespace.

If called interactively, enable Purescript-Simple-Indent mode if
ARG is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

Runs `purescript-simple-indent-hook' on activation.

\(fn &optional ARG)" t nil)

(autoload 'turn-on-purescript-simple-indent "purescript-simple-indent" "\
Turn on function `purescript-simple-indent-mode'." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-simple-indent" '("purescript-simple-indent" "turn-off-purescript-simple-indent")))



(autoload 'purescript-sort-imports "purescript-sort-imports" nil t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-sort-imports" '("purescript-sort-imports-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-str" '("purescript-str-")))



(autoload 'purescript-trim "purescript-string" "\


\(fn STRING)" nil nil)

(autoload 'purescript-string-take "purescript-string" "\
Take n chars from string.

\(fn STRING N)" nil nil)

(autoload 'purescript-is-prefix-of "purescript-string" "\
Is x string a prefix of y string?

\(fn X Y)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-string" '("purescript-string")))



(autoload 'turn-on-purescript-unicode-input-method "purescript-unicode-input-method" "\
Set input method `purescript-unicode'.
See Info node `Unicode(purescript-mode)' for more details." t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-utils" '("purescript-utils-")))



(autoload 'purescript-yas-complete "purescript-yas" "\


\(fn &rest ARGS)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "purescript-yas" '("purescript-yas-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/powershell-20201005.1642/powershell-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/powershell-20201005.1642/powershell-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/powershell-20201005.1642/powershell-autoloads.el") (car load-path))))



(add-to-list 'auto-mode-alist '("\\.ps[dm]?1\\'" . powershell-mode))

(autoload 'powershell-mode "powershell" "\
Major mode for editing PowerShell scripts.

\\{powershell-mode-map}
Entry to this mode calls the value of `powershell-mode-hook' if
that value is non-nil.

\(fn)" t nil)

(autoload 'powershell "powershell" "\
Run an inferior PowerShell.
If BUFFER is non-nil, use it to hold the powershell
process.  Defaults to *PowerShell*.

Interactively, a prefix arg means to prompt for BUFFER.

If BUFFER exists but the shell process is not running, it makes a
new shell.

If BUFFER exists and the shell process is running, just switch to
BUFFER.

If PROMPT-STRING is non-nil, sets the prompt to the given value.

See the help for `shell' for more details.  (Type
\\[describe-mode] in the shell buffer for a list of commands.)

\(fn &optional BUFFER PROMPT-STRING)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "powershell" '("explicit-powershell.exe-args" "powershell-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/parseclj-20220422.936/parseclj-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/parseclj-20220422.936/parseclj-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/parseclj-20220422.936/parseclj-autoloads.el") (car load-path))))



(register-definition-prefixes "parseclj" '("parseclj-"))



(register-definition-prefixes "parseclj-alist" '("parseclj-"))



(register-definition-prefixes "parseclj-ast" '("parseclj-ast-"))



(register-definition-prefixes "parseclj-lex" '("parseclj-lex-"))



(register-definition-prefixes "parseclj-parser" '("parseclj-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/parseedn-20220520.835/parseedn-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/parseedn-20220520.835/parseedn-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/parseedn-20220520.835/parseedn-autoloads.el") (car load-path))))



(register-definition-prefixes "parseedn" '("parseedn-"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/orderless-20210603.1335/orderless-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/orderless-20210603.1335/orderless-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/orderless-20210603.1335/orderless-autoloads.el") (car load-path))))



(autoload 'orderless-filter "orderless" "\
Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.

\(fn STRING TABLE &optional PRED)" nil nil)

(autoload 'orderless-all-completions "orderless" "\
Split STRING into components and find entries TABLE matching all.
The predicate PRED is used to constrain the entries in TABLE.  The
matching portions of each candidate are highlighted.
This function is part of the `orderless' completion style.

\(fn STRING TABLE PRED POINT)" nil nil)

(autoload 'orderless-try-completion "orderless" "\
Complete STRING to unique matching entry in TABLE.
This uses `orderless-all-completions' to find matches for STRING
in TABLE among entries satisfying PRED.  If there is only one
match, it completes to that match.  If there are no matches, it
returns nil.  In any other case it \"completes\" STRING to
itself, without moving POINT.
This function is part of the `orderless' completion style.

\(fn STRING TABLE PRED POINT)" nil nil)

(add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions "Completion of multiple components, in any order."))

(autoload 'orderless-ivy-re-builder "orderless" "\
Convert STR into regexps for use with ivy.
This function is for integration of orderless with ivy, use it as
a value in `ivy-re-builders-alist'.

\(fn STR)" nil nil)

(with-eval-after-load 'ivy (add-to-list 'ivy-highlight-functions-alist '(orderless-ivy-re-builder . orderless-ivy-highlight)))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "orderless" '("orderless-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/markdown-mode-20210710.1646/markdown-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/markdown-mode-20210710.1646/markdown-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/markdown-mode-20210710.1646/markdown-mode-autoloads.el") (car load-path))))



(autoload 'markdown-mode "markdown-mode" "\
Major mode for editing Markdown files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode" "\
Major mode for editing GitHub Flavored Markdown files.

\(fn)" t nil)

(autoload 'markdown-view-mode "markdown-mode" "\
Major mode for viewing Markdown content.

\(fn)" t nil)

(autoload 'gfm-view-mode "markdown-mode" "\
Major mode for viewing GitHub Flavored Markdown content.

\(fn)" t nil)

(autoload 'markdown-live-preview-mode "markdown-mode" "\
Toggle native previewing on save for a specific markdown file.

If called interactively, enable Markdown-Live-Preview mode if ARG
is positive, and disable it if ARG is zero or negative.  If
called from Lisp, also enable the mode if ARG is omitted or nil,
and toggle it if ARG is `toggle'; disable the mode otherwise.

\(fn &optional ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "markdown-mode" '("defun-markdown-" "gfm-" "markdown")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/marginalia-20220707.914/marginalia-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/marginalia-20220707.914/marginalia-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/marginalia-20220707.914/marginalia-autoloads.el") (car load-path))))



(defvar marginalia-mode nil "\
Non-nil if Marginalia mode is enabled.
See the `marginalia-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `marginalia-mode'.")

(custom-autoload 'marginalia-mode "marginalia" nil)

(autoload 'marginalia-mode "marginalia" "\
Annotate completion candidates with richer information.

This is a minor mode.  If called interactively, toggle the
`Marginalia mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='marginalia-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\(fn &optional ARG)" t nil)

(autoload 'marginalia-cycle "marginalia" "\
Cycle between annotators in `marginalia-annotator-registry'." t nil)

(register-definition-prefixes "marginalia" '("marginalia-"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/lv-20200507.1518/lv-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "lv" '("lv-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/kotlin-mode-20220527.1646/kotlin-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/kotlin-mode-20220527.1646/kotlin-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/kotlin-mode-20220527.1646/kotlin-mode-autoloads.el") (car load-path))))



(autoload 'kotlin-mode "kotlin-mode" "\
Major mode for editing Kotlin.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.kts?\\'" . kotlin-mode) t)

(register-definition-prefixes "kotlin-mode" '("kotlin-"))



(register-definition-prefixes "kotlin-mode-lexer" '("kotlin-mode--"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/json-snatcher-20200916.1717/json-snatcher-autoloads.el") (car load-path))))



(autoload 'jsons-print-path "json-snatcher" "\
Print the path to the JSON value under point, and save it in the kill ring.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-snatcher" '("jsons-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/json-reformat-20160212.853/json-reformat-autoloads.el") (car load-path))))



(autoload 'json-reformat-region "json-reformat" "\
Reformat the JSON in the specified region.

If you want to customize the reformat style,
please see the documentation of `json-reformat:indent-width'
and `json-reformat:pretty-string?'.

\(fn BEGIN END)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-reformat" '("json-reformat")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-mode-20190123.422/json-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/json-mode-20190123.422/json-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/json-mode-20190123.422/json-mode-autoloads.el") (car load-path))))



(defconst json-mode-standard-file-ext '(".json" ".jsonld") "\
List of JSON file extensions.")

(defsubst json-mode--update-auto-mode (filenames) "\
Update the `json-mode' entry of `auto-mode-alist'.

FILENAMES should be a list of file as string.
Return the new `auto-mode-alist' entry" (let* ((new-regexp (rx-to-string (\` (seq (eval (cons (quote or) (append json-mode-standard-file-ext (quote (\, filenames))))) eot)))) (new-entry (cons new-regexp (quote json-mode))) (old-entry (when (boundp (quote json-mode--auto-mode-entry)) json-mode--auto-mode-entry))) (setq auto-mode-alist (delete old-entry auto-mode-alist)) (add-to-list (quote auto-mode-alist) new-entry) new-entry))

(defvar json-mode-auto-mode-list '(".babelrc" ".bowerrc" "composer.lock") "\
List of filename as string to pass for the JSON entry of
`auto-mode-alist'.

Note however that custom `json-mode' entries in `auto-mode-alist'
won’t be affected.")

(custom-autoload 'json-mode-auto-mode-list "json-mode" nil)

(defvar json-mode--auto-mode-entry (json-mode--update-auto-mode json-mode-auto-mode-list) "\
Regexp generated from the `json-mode-auto-mode-list'.")

(autoload 'json-mode "json-mode" "\
Major mode for editing JSON files

\(fn)" t nil)

(add-to-list 'magic-fallback-mode-alist '("^[{[]$" . json-mode))

(autoload 'json-mode-show-path "json-mode" "\
Print the path to the node at point to the minibuffer, and yank to the kill ring.

\(fn)" t nil)

(autoload 'json-mode-kill-path "json-mode" "\


\(fn)" t nil)

(autoload 'json-mode-beautify "json-mode" "\
Beautify / pretty-print the active region (or the entire buffer if no active region).

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "json-mode" '("json-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/inf-ruby-20210607.2336/inf-ruby-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/inf-ruby-20210607.2336/inf-ruby-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/inf-ruby-20210607.2336/inf-ruby-autoloads.el") (car load-path))))



(defvar ruby-source-modes '(ruby-mode enh-ruby-mode) "\
Used to determine if a buffer contains Ruby source code.
If it's loaded into a buffer that is in one of these major modes, it's
considered a ruby source file by `ruby-load-file'.
Used by these commands to determine defaults.")

(autoload 'inf-ruby-setup-keybindings "inf-ruby" "\
Hook up `inf-ruby-minor-mode' to each of `ruby-source-modes'." nil nil)

(autoload 'inf-ruby-minor-mode "inf-ruby" "\
Minor mode for interacting with the inferior process buffer.

If called interactively, enable Inf-Ruby minor mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

The following commands are available:

\\{inf-ruby-minor-mode-map}

\(fn &optional ARG)" t nil)

(autoload 'inf-ruby "inf-ruby" "\
Run an inferior Ruby process in a buffer.
With prefix argument, prompts for which Ruby implementation
\(from the list `inf-ruby-implementations') to use.

If there is a Ruby process running in an existing buffer, switch
to that buffer. Otherwise create a new buffer.

\(fn &optional IMPL)" t nil)

(autoload 'run-ruby "inf-ruby" "\
Run an inferior Ruby process, input and output in a buffer.

If there is a process already running in a corresponding buffer,
switch to that buffer. Otherwise create a new buffer.

The consecutive buffer names will be:
`*NAME*', `*NAME*<2>', `*NAME*<3>' and so on.

COMMAND defaults to the default entry in
`inf-ruby-implementations'. NAME defaults to \"ruby\".

Runs the hooks `comint-mode-hook' and `inf-ruby-mode-hook'.

Type \\[describe-mode] in the process buffer for the list of commands.

\(fn &optional COMMAND NAME)" t nil)

(autoload 'inf-ruby-switch-setup "inf-ruby" "\
Modify `rspec-compilation-mode' and `ruby-compilation-mode'
keymaps to bind `inf-ruby-switch-from-compilation' to `С-x C-q'." nil nil)

(autoload 'inf-ruby-console-auto "inf-ruby" "\
Run the appropriate Ruby console command.
The command and the directory to run it from are detected
automatically." t nil)

(autoload 'inf-ruby-console-zeus "inf-ruby" "\
Run Rails console in DIR using Zeus.

\(fn DIR)" t nil)

(autoload 'inf-ruby-console-rails "inf-ruby" "\
Run Rails console in DIR.

\(fn DIR)" t nil)

(autoload 'inf-ruby-console-gem "inf-ruby" "\
Run IRB console for the gem in DIR.
The main module should be loaded automatically.  If DIR contains a
Gemfile, it should use the `gemspec' instruction.

\(fn DIR)" t nil)

(autoload 'inf-ruby-auto-enter "inf-ruby" "\
Switch to `inf-ruby-mode' if the breakpoint pattern matches the current line." nil nil)

(autoload 'inf-ruby-auto-exit "inf-ruby" "\
Return to the previous compilation mode if INPUT is a debugger exit command.

\(fn INPUT)" nil nil)

(autoload 'inf-ruby-console-script "inf-ruby" "\
Run custom bin/console, console or console.rb in DIR.

\(fn DIR)" t nil)

(autoload 'inf-ruby-console-default "inf-ruby" "\
Run Pry, or bundle console, in DIR.

\(fn DIR)" t nil)

(autoload 'inf-ruby-file-contents-match "inf-ruby" "\


\(fn FILE REGEXP &optional MATCH-GROUP)" nil nil)
 (dolist (mode ruby-source-modes) (add-hook (intern (format "%s-hook" mode)) 'inf-ruby-minor-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inf-ruby" '("inf-ruby-" "ruby-" "run-ruby-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dash-20210826.1149/dash-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dash-20210826.1149/dash-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/dash-20210826.1149/dash-autoloads.el") (car load-path))))



(autoload 'dash-fontify-mode "dash" "\
Toggle fontification of Dash special variables.

If called interactively, enable Dash-Fontify mode if ARG is
positive, and disable it if ARG is zero or negative.  If called
from Lisp, also enable the mode if ARG is omitted or nil, and
toggle it if ARG is `toggle'; disable the mode otherwise.

Dash-Fontify mode is a buffer-local minor mode intended for Emacs
Lisp buffers.  Enabling it causes the special variables bound in
anaphoric Dash macros to be fontified.  These anaphoras include
`it', `it-index', `acc', and `other'.  In older Emacs versions
which do not dynamically detect macros, Dash-Fontify mode
additionally fontifies Dash macro calls.

See also `dash-fontify-mode-lighter' and
`global-dash-fontify-mode'.

\(fn &optional ARG)" t nil)

(put 'global-dash-fontify-mode 'globalized-minor-mode t)

(defvar global-dash-fontify-mode nil "\
Non-nil if Global Dash-Fontify mode is enabled.
See the `global-dash-fontify-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `global-dash-fontify-mode'.")

(custom-autoload 'global-dash-fontify-mode "dash" nil)

(autoload 'global-dash-fontify-mode "dash" "\
Toggle Dash-Fontify mode in all buffers.
With prefix ARG, enable Global Dash-Fontify mode if ARG is positive;
otherwise, disable it.  If called from Lisp, enable the mode if
ARG is omitted or nil.

Dash-Fontify mode is enabled in all buffers where
`dash--turn-on-fontify-mode' would do it.
See `dash-fontify-mode' for more information on Dash-Fontify mode.

\(fn &optional ARG)" t nil)

(autoload 'dash-register-info-lookup "dash" "\
Register the Dash Info manual with `info-lookup-symbol'.
This allows Dash symbols to be looked up with \\[info-lookup-symbol]." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dash" '("!cdr" "!cons" "--" "->" "-a" "-butlast" "-c" "-d" "-e" "-f" "-gr" "-i" "-juxt" "-keep" "-l" "-m" "-no" "-o" "-p" "-r" "-s" "-t" "-u" "-value-to-list" "-when-let" "-zip" "dash-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/ht-20210119.741/ht-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/ht-20210119.741/ht-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/ht-20210119.741/ht-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ht" 'nil))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/go-mode-20210201.1458/go-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/go-mode-20210201.1458/go-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/go-mode-20210201.1458/go-mode-autoloads.el") (car load-path))))



(autoload 'go-mode "go-mode" "\
Major mode for editing Go source text.

This mode provides (not just) basic editing capabilities for
working with Go code. It offers almost complete syntax
highlighting, indentation that is almost identical to gofmt and
proper parsing of the buffer content to allow features such as
navigation by function, manipulation of comments or detection of
strings.

In addition to these core features, it offers various features to
help with writing Go code. You can directly run buffer content
through gofmt, read godoc documentation from within Emacs, modify
and clean up the list of package imports or interact with the
Playground (uploading and downloading pastes).

The following extra functions are defined:

- `gofmt'
- `godoc' and `godoc-at-point'
- `go-import-add'
- `go-remove-unused-imports'
- `go-goto-arguments'
- `go-goto-docstring'
- `go-goto-function'
- `go-goto-function-name'
- `go-goto-imports'
- `go-goto-return-values'
- `go-goto-method-receiver'
- `go-play-buffer' and `go-play-region'
- `go-download-play'
- `godef-describe' and `godef-jump'
- `go-coverage'
- `go-set-project'
- `go-reset-gopath'

If you want to automatically run `gofmt' before saving a file,
add the following hook to your emacs configuration:

\(add-hook 'before-save-hook #'gofmt-before-save)

If you want to use `godef-jump' instead of etags (or similar),
consider binding godef-jump to `M-.', which is the default key
for `find-tag':

\(add-hook 'go-mode-hook (lambda ()
                          (local-set-key (kbd \"M-.\") #'godef-jump)))

Please note that godef is an external dependency. You can install
it with

go get github.com/rogpeppe/godef


If you're looking for even more integration with Go, namely
on-the-fly syntax checking, auto-completion and snippets, it is
recommended that you look at flycheck
\(see URL `https://github.com/flycheck/flycheck') or flymake in combination
with goflymake (see URL `https://github.com/dougm/goflymake'), gocode
\(see URL `https://github.com/nsf/gocode'), go-eldoc
\(see URL `github.com/syohex/emacs-go-eldoc') and yasnippet-go
\(see URL `https://github.com/dominikh/yasnippet-go')

\(fn)" t nil)

(add-to-list 'auto-mode-alist (cons "\\.go\\'" 'go-mode))

(autoload 'gofmt-before-save "go-mode" "\
Add this to .emacs to run gofmt on the current buffer when saving:
\(add-hook 'before-save-hook 'gofmt-before-save).

Note that this will cause ‘go-mode’ to get loaded the first time
you save any file, kind of defeating the point of autoloading." t nil)

(autoload 'godoc "go-mode" "\
Show Go documentation for QUERY, much like \\<go-mode-map>\\[man].

\(fn QUERY)" t nil)

(autoload 'go-download-play "go-mode" "\
Download a paste from the playground and insert it in a Go buffer.
Tries to look for a URL at point.

\(fn URL)" t nil)

(autoload 'go-dot-mod-mode "go-mode" "\
A major mode for editing go.mod files.

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("go\\.mod\\'" . go-dot-mod-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "go-mode" '("go-" "god" "gofmt")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/gdscript-mode-20220510.944/gdscript-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/gdscript-mode-20220510.944/gdscript-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/gdscript-mode-20220510.944/gdscript-mode-autoloads.el") (car load-path))))



(register-definition-prefixes "gdscript-comint" '("gdscript-comint--" "godot-mode"))



(register-definition-prefixes "gdscript-comint-gdformat" '("gdformat-mode" "gdscript-comint-gdformat--"))



(register-definition-prefixes "gdscript-completion" '("gdscript-completion-"))



(register-definition-prefixes "gdscript-customization" '("gdscript-"))



(autoload 'gdscript-debug-make-server "gdscript-debug" nil t nil)

(register-definition-prefixes "gdscript-debug" '("gdscript-"))



(autoload 'gdscript-docs-browse-api "gdscript-docs" "\
Open the main page of Godot API. Use the universal prefix (C-u) to force browsing the online API.

\(fn &optional FORCE-ONLINE)" t nil)

(register-definition-prefixes "gdscript-docs" '("gdscript-docs-"))



(register-definition-prefixes "gdscript-fill-paragraph" '("gdscript-fill-paragraph"))



(register-definition-prefixes "gdscript-format" '("gdscript-"))



(defvar gdscript-godot--debug-options-hydra :not-list)

(register-definition-prefixes "gdscript-godot" '("gdscript-godot-"))



(register-definition-prefixes "gdscript-history" '("gdscript-history--"))



(defvar gdscript-hydra--open nil)

(register-definition-prefixes "gdscript-hydra" '("gdscript-hydra-"))



(register-definition-prefixes "gdscript-imenu" '("gdscript-imenu-"))



(register-definition-prefixes "gdscript-indent-and-nav" '("gdscript-"))



(register-definition-prefixes "gdscript-keywords" '("gdscript-"))



(add-to-list 'auto-mode-alist '("\\.gd\\'" . gdscript-mode))

(add-to-list 'auto-mode-alist '("\\.tscn\\'" . conf-toml-mode))

(add-to-list 'auto-mode-alist '("\\.tres\\'" . conf-toml-mode))

(autoload 'gdscript-mode "gdscript-mode" "\
Major mode for editing Godot GDScript files.

\(fn)" t nil)

(register-definition-prefixes "gdscript-mode" '("gdscript-"))



(register-definition-prefixes "gdscript-project" '("gdscript-project--"))



(autoload 'gdscript-rx-to-string "gdscript-rx" "\
Translate FORM from `rx' sexp syntax into a string regexp.
The arguments to `literal' and `regexp' forms inside FORM must be
constant strings.
If NO-GROUP is non-nil, don't bracket the result in a non-capturing
group.

For extending the `rx' notation in FORM, use `gdscript-rx-define' or `gdscript-rx-let-eval'.

\(fn FORM &optional NO-GROUP)" nil nil)

(autoload 'gdscript-rx-build-rx "gdscript-rx" "\
Translate regex REGEXPS in sexp form to a regexp string.
Each argument is one of the forms below; RX is a subform, and
RX... stands for zero or more RXs. For details, see Info
node `(elisp) Rx Notation'. See `gdscript-rx-to-string' for the
corresponding function.

STRING         Match a literal string.
CHAR           Match a literal character.

\(seq RX...)    Match the RXs in sequence.  Alias: :, sequence, and.
\(or RX...)     Match one of the RXs.  Alias: |.

\(zero-or-more RX...) Match RXs zero or more times.  Alias: 0+.
\(one-or-more RX...)  Match RXs one or more times.  Alias: 1+.
\(zero-or-one RX...)  Match RXs or the empty string.
Alias: opt, optional.
\(* RX...)       Match RXs zero or more times; greedy.
\(+ RX...)       Match RXs one or more times; greedy.
\(? RX...)       Match RXs or the empty string; greedy.
\(*? RX...)      Match RXs zero or more times; non-greedy.
\(+? RX...)      Match RXs one or more times; non-greedy.
\(?? RX...)      Match RXs or the empty string; non-greedy.
\(= N RX...)     Match RXs exactly N times.
\(>= N RX...)    Match RXs N or more times.
\(** N M RX...)  Match RXs N to M times.  Alias: repeat.
\(minimal-match RX)  Match RX, with zero-or-more, one-or-more, zero-or-one
                and aliases using non-greedy matching.
\(maximal-match RX)  Match RX, with zero-or-more, one-or-more, zero-or-one
                and aliases using greedy matching, which is the default.

\(any SET...)    Match a character from one of the SETs.  Each SET is a
                character, a string, a range as string \"A-Z\" or cons
                (?A . ?Z), or a character class (see below).  Alias: in, char.
\(not CHARSPEC)  Match one character not matched by CHARSPEC.  CHARSPEC
                can be a character, single-char string, (any ...), (or ...),
                (intersection ...), (syntax ...), (category ...),
                or a character class.
\(intersection CHARSET...) Match all CHARSETs.
                CHARSET is (any...), (not...), (or...) or (intersection...),
                a character or a single-char string.
not-newline     Match any character except a newline.  Alias: nonl.
anychar         Match any character.  Alias: anything.
unmatchable     Never match anything at all.

CHARCLASS       Match a character from a character class.  One of:
 alpha, alphabetic, letter   Alphabetic characters (defined by Unicode).
 alnum, alphanumeric         Alphabetic or decimal digit chars (Unicode).
 digit numeric, num          0-9.
 xdigit, hex-digit, hex      0-9, A-F, a-f.
 cntrl, control              ASCII codes 0-31.
 blank                       Horizontal whitespace (Unicode).
 space, whitespace, white    Chars with whitespace syntax.
 lower, lower-case           Lower-case chars, from current case table.
 upper, upper-case           Upper-case chars, from current case table.
 graph, graphic              Graphic characters (Unicode).
 print, printing             Whitespace or graphic (Unicode).
 punct, punctuation          Not control, space, letter or digit (ASCII);
                              not word syntax (non-ASCII).
 word, wordchar              Characters with word syntax.
 ascii                       ASCII characters (codes 0-127).
 nonascii                    Non-ASCII characters (but not raw bytes).

\(syntax SYNTAX)  Match a character with syntax SYNTAX, being one of:
  whitespace, punctuation, word, symbol, open-parenthesis,
  close-parenthesis, expression-prefix, string-quote,
  paired-delimiter, escape, character-quote, comment-start,
  comment-end, string-delimiter, comment-delimiter

\(category CAT)   Match a character in category CAT, being one of:
  space-for-indent, base, consonant, base-vowel,
  upper-diacritical-mark, lower-diacritical-mark, tone-mark, symbol,
  digit, vowel-modifying-diacritical-mark, vowel-sign,
  semivowel-lower, not-at-end-of-line, not-at-beginning-of-line,
  alpha-numeric-two-byte, chinese-two-byte, greek-two-byte,
  japanese-hiragana-two-byte, indian-two-byte,
  japanese-katakana-two-byte, strong-left-to-right,
  korean-hangul-two-byte, strong-right-to-left, cyrillic-two-byte,
  combining-diacritic, ascii, arabic, chinese, ethiopic, greek,
  korean, indian, japanese, japanese-katakana, latin, lao,
  tibetan, japanese-roman, thai, vietnamese, hebrew, cyrillic,
  can-break

Zero-width assertions: these all match the empty string in specific places.
 line-start         At the beginning of a line.  Alias: bol.
 line-end           At the end of a line.  Alias: eol.
 string-start       At the start of the string or buffer.
                     Alias: buffer-start, bos, bot.
 string-end         At the end of the string or buffer.
                     Alias: buffer-end, eos, eot.
 point              At point.
 word-start         At the beginning of a word.  Alias: bow.
 word-end           At the end of a word.  Alias: eow.
 word-boundary      At the beginning or end of a word.
 not-word-boundary  Not at the beginning or end of a word.
 symbol-start       At the beginning of a symbol.
 symbol-end         At the end of a symbol.

\(group RX...)  Match RXs and define a capture group.  Alias: submatch.
\(group-n N RX...) Match RXs and define capture group N.  Alias: submatch-n.
\(backref N)    Match the text that capture group N matched.

\(literal EXPR) Match the literal string from evaluating EXPR at run time.
\(regexp EXPR)  Match the string regexp from evaluating EXPR at run time.
\(eval EXPR)    Match the rx sexp from evaluating EXPR at compile time.

Additional constructs can be defined using `gdscript-rx-define' and
`gdscript-rx-let',which see.

\(fn REGEXPS...)" nil t)

(autoload 'gdscript-rx-let-eval "gdscript-rx" "\
Evaluate BODY with local BINDINGS for `gdscript-rx-to-string'.
BINDINGS, after evaluation, is a list of definitions each on the form
\(NAME [(ARGS...)] RX), in effect for calls to `gdscript-rx-to-string'
in BODY.

For bindings without an ARGS list, NAME is defined as an alias
for the `rx' expression RX.  Where ARGS is supplied, NAME is
defined as an `rx' form with ARGS as argument list.  The
parameters are bound from the values in the (NAME ...) form and
are substituted in RX.  ARGS can contain `&rest' parameters,
whose values are spliced into RX where the parameter name occurs.

Any previous definitions with the same names are shadowed during
the expansion of BODY only.
For extensions when using the `rx' macro, use `gdscript-rx-let'.
To make global rx extensions, use `gdscript-rx-define'.
For more details, see Info node `(elisp) Extending Rx'.

\(fn BINDINGS BODY...)" nil t)

(function-put 'gdscript-rx-let-eval 'lisp-indent-function '1)

(autoload 'gdscript-rx-let "gdscript-rx" "\
Evaluate BODY with local BINDINGS for `rx'.
BINDINGS is an unevaluated list of bindings each on the form
\(NAME [(ARGS...)] RX).
They are bound lexically and are available in `rx' expressions in
BODY only.

For bindings without an ARGS list, NAME is defined as an alias
for the `rx' expression RX.  Where ARGS is supplied, NAME is
defined as an `rx' form with ARGS as argument list.  The
parameters are bound from the values in the (NAME ...) form and
are substituted in RX.  ARGS can contain `&rest' parameters,
whose values are spliced into RX where the parameter name occurs.

Any previous definitions with the same names are shadowed during
the expansion of BODY only.
For local extensions to `gdscript-rx-to-string', use `gdscript-rx-let-eval'.
To make global rx extensions, use `gdscript-rx-define'.
For more details, see Info node `(elisp) Extending Rx'.

\(fn BINDINGS BODY...)" nil t)

(function-put 'gdscript-rx-let 'lisp-indent-function '1)

(autoload 'gdscript-rx-define "gdscript-rx" "\
Define NAME as a global `rx' definition.
If the DEFINITION args list is omitted, define NAME as an alias for the `rx'
expression RX.

If the args list is supplied, define NAME as an `rx' form with
args as argument list.  The parameters are bound from the values
in the (NAME ...) form and are substituted in RX.
args can contain `&rest' parameters, whose values are spliced
into RX where the parameter name occurs.

Any previous global definition of NAME is overwritten with the new one.
To make local rx extensions, use `gdscript-rx-let' for `rx',
`gdscript-rx-let-eval' for `gdscript-rx-to-string'.
For more details, see Info node `(elisp) Extending Rx'.

\(fn NAME [(args...)] RX)" nil t)

(function-put 'gdscript-rx-define 'lisp-indent-function '1)

(register-definition-prefixes "gdscript-rx" '("gdscript-rx"))



(register-definition-prefixes "gdscript-syntax" '("gdscript-"))



(register-definition-prefixes "gdscript-utils" '("gdscript-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/fsharp-mode-20210807.1417/fsharp-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/fsharp-mode-20210807.1417/fsharp-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/fsharp-mode-20210807.1417/fsharp-mode-autoloads.el") (car load-path))))



(add-to-list 'auto-mode-alist '("\\.fs[iylx]?\\'" . fsharp-mode))

(autoload 'fsharp-mode "fsharp-mode" "\


\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fsharp-mode" '("fsharp-" "running-xemacs")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fsharp-mode-font" '("def-fsharp-compiled-var" "fsharp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fsharp-mode-structure" '("beginning-of-fsharp-def-or-class" "fsharp-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "fsharp-mode-util" '("fsharp-")))



(autoload 'run-fsharp "inf-fsharp-mode" "\
Run an inferior fsharp process.
Input and output via buffer `*inferior-fsharp*'.

\(fn &optional CMD)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "inf-fsharp-mode" '("fsharp-" "inferior-fsharp-")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/feature-mode-20200815.1617/feature-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/feature-mode-20200815.1617/feature-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/feature-mode-20200815.1617/feature-mode-autoloads.el") (car load-path))))



(autoload 'feature-mode "feature-mode" "\
Major mode for editing plain text stories" t nil)

(add-to-list 'auto-mode-alist '("\\.feature\\'" . feature-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "feature-mode" '("build-keyword-matcher" "can-run-bundle" "expand-home-shellism" "feature-" "given-when-then-wordlength" "load-gherkin-i10n" "parse-gherkin-l10n" "project-file-exists" "should-run-docker-compose" "try-find-next")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/f-20210624.1103/f-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/f-20210624.1103/f-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/f-20210624.1103/f-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "f" '("f-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/expand-region-20210708.1952/expand-region-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/expand-region-20210708.1952/expand-region-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/expand-region-20210708.1952/expand-region-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cc-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "clojure-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "cperl-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "css-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "enh-ruby-mode-expansions" '("er/add-enh-ruby-mode-expansions")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "er-basic-expansions" '("er--" "er/mark-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "erlang-mode-expansions" '("er/add-erlang-mode-expansions")))



(autoload 'er/expand-region "expand-region" "\
Increase selected region by semantic units.

With prefix argument expands the region that many times.
If prefix argument is negative calls `er/contract-region'.
If prefix argument is 0 it resets point and mark to their state
before calling `er/expand-region' for the first time.

\(fn ARG)" t nil)



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-core" '("er--" "er/")))



(let ((loads (get 'expand-region 'custom-loads))) (if (member '"expand-region-custom" loads) nil (put 'expand-region 'custom-loads (cons '"expand-region-custom" loads))))

(defvar expand-region-preferred-python-mode 'python "\
The name of your preferred python mode")

(custom-autoload 'expand-region-preferred-python-mode "expand-region-custom" t)

(defvar expand-region-guess-python-mode t "\
If expand-region should attempt to guess your preferred python mode")

(custom-autoload 'expand-region-guess-python-mode "expand-region-custom" t)

(defvar expand-region-autocopy-register "" "\
If set to a string of a single character (try \"e\"), then the
contents of the most recent expand or contract command will
always be copied to the register named after that character.")

(custom-autoload 'expand-region-autocopy-register "expand-region-custom" t)

(defvar expand-region-skip-whitespace t "\
If expand-region should skip past whitespace on initial expansion")

(custom-autoload 'expand-region-skip-whitespace "expand-region-custom" t)

(defvar expand-region-fast-keys-enabled t "\
If expand-region should bind fast keys after initial expand/contract")

(custom-autoload 'expand-region-fast-keys-enabled "expand-region-custom" t)

(defvar expand-region-contract-fast-key "-" "\
Key to use after an initial expand/contract to contract once more.")

(custom-autoload 'expand-region-contract-fast-key "expand-region-custom" t)

(defvar expand-region-reset-fast-key "0" "\
Key to use after an initial expand/contract to undo.")

(custom-autoload 'expand-region-reset-fast-key "expand-region-custom" t)

(defvar expand-region-exclude-text-mode-expansions '(html-mode nxml-mode) "\
List of modes which derive from `text-mode' for which text mode expansions are not appropriate.")

(custom-autoload 'expand-region-exclude-text-mode-expansions "expand-region-custom" t)

(defvar expand-region-smart-cursor nil "\
Defines whether the cursor should be placed intelligently after expansion.

If set to t, and the cursor is already at the beginning of the new region,
keep it there; otherwise, put it at the end of the region.

If set to nil, always place the cursor at the beginning of the region.")

(custom-autoload 'expand-region-smart-cursor "expand-region-custom" t)

(define-obsolete-variable-alias 'er/enable-subword-mode\? 'expand-region-subword-enabled "2019-03-23")

(defvar expand-region-subword-enabled nil "\
Whether expand-region should use subword expansions.")

(custom-autoload 'expand-region-subword-enabled "expand-region-custom" t)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "expand-region-custom" '("expand-region-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "feature-mode-expansions" '("er--block-between-keywords" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "html-mode-expansions" '("er--" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "js2-mode-expansions" '("er/add-js2-mode-expansions" "js2-mark-parent-statement")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "jsp-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "latex-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "nxml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "octave-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-expansions" '("er--python-string-delimiter" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-el-fgallina-expansions" '("er--python-" "er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "python-mode-expansions" '("er--" "er/" "py-goto-beyond-clause")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ruby-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "sml-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "subword-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "text-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "the-org-mode-expansions" '("er/")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "web-mode-expansions" '("er/add-web-mode-expansions")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "yaml-mode-expansions" '("er--" "er/" "yaml-indent")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-20221020.1010/eglot-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-20221020.1010/eglot-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-20221020.1010/eglot-autoloads.el") (car load-path))))



(autoload 'eglot "eglot" "\
Manage a project with a Language Server Protocol (LSP) server.

The LSP server of CLASS is started (or contacted) via CONTACT.
If this operation is successful, current *and future* file
buffers of MANAGED-MAJOR-MODE inside PROJECT become \"managed\"
by the LSP server, meaning information about their contents is
exchanged periodically to provide enhanced code-analysis via
`xref-find-definitions', `flymake-mode', `eldoc-mode',
`completion-at-point', among others.

Interactively, the command attempts to guess MANAGED-MAJOR-MODE
from current buffer, CLASS and CONTACT from
`eglot-server-programs' and PROJECT from
`project-find-functions'.  The search for active projects in this
context binds `eglot-lsp-context' (which see).

If it can't guess, the user is prompted.  With a single
\\[universal-argument] prefix arg, it always prompt for COMMAND.
With two \\[universal-argument] prefix args, also prompts for
MANAGED-MAJOR-MODE.

PROJECT is a project object as returned by `project-current'.

CLASS is a subclass of `eglot-lsp-server'.

CONTACT specifies how to contact the server.  It is a
keyword-value plist used to initialize CLASS or a plain list as
described in `eglot-server-programs', which see.

LANGUAGE-ID is the language ID string to send to the server for
MANAGED-MAJOR-MODE, which matters to a minority of servers.

INTERACTIVE is t if called interactively.

\(fn MANAGED-MAJOR-MODE PROJECT CLASS CONTACT LANGUAGE-ID &optional INTERACTIVE)" t nil)

(autoload 'eglot-ensure "eglot" "\
Start Eglot session for current buffer if there isn't one." nil nil)

(put 'eglot-workspace-configuration 'safe-local-variable 'listp)

(register-definition-prefixes "eglot" '("eglot-"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-fsharp-20210330.1442/eglot-fsharp-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-fsharp-20210330.1442/eglot-fsharp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/eglot-fsharp-20210330.1442/eglot-fsharp-autoloads.el") (car load-path))))



(autoload 'eglot-fsharp "eglot-fsharp" "\
Return `eglot' contact when FsAutoComplete is installed.
Ensure FsAutoComplete is installed (when called INTERACTIVE).

\(fn INTERACTIVE)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "eglot-fsharp" '("eglot-fs")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dotenv-mode-20191027.2129/dotenv-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dotenv-mode-20191027.2129/dotenv-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/dotenv-mode-20191027.2129/dotenv-mode-autoloads.el") (car load-path))))



(autoload 'dotenv-mode "dotenv-mode" "\
Major mode for `.env' files.

\(fn)" t nil)

(mapc (lambda (s) (add-to-list 'auto-mode-alist `(,s . dotenv-mode))) '("\\.env\\'" "\\.env\\.example\\'"))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dotenv-mode" '("dotenv-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dockerfile-mode-20211016.1545/dockerfile-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dockerfile-mode-20211016.1545/dockerfile-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/dockerfile-mode-20211016.1545/dockerfile-mode-autoloads.el") (car load-path))))



(autoload 'dockerfile-build-buffer "dockerfile-mode" "\
Build an image called IMAGE-NAME based upon the buffer.

If prefix arg NO-CACHE is set, don't cache the image.
The build string will be of the format:
`sudo docker build --no-cache --tag IMAGE-NAME --build-args arg1.. -f filename directory`

\(fn IMAGE-NAME &optional NO-CACHE)" t nil)

(autoload 'dockerfile-build-no-cache-buffer "dockerfile-mode" "\
Build an image called IMAGE-NAME based upon the buffer without cache.

\(fn IMAGE-NAME)" t nil)

(autoload 'dockerfile-mode "dockerfile-mode" "\
A major mode to edit Dockerfiles.
\\{dockerfile-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("/Dockerfile\\(?:\\.[^/\\]*\\)?\\'" . dockerfile-mode))

(add-to-list 'auto-mode-alist '("\\.dockerfile\\'" . dockerfile-mode))

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "dockerfile-mode" '("dockerfile-")))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/docker-tramp-20220219.420/docker-tramp-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/docker-tramp-20220219.420/docker-tramp-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/docker-tramp-20220219.420/docker-tramp-autoloads.el") (car load-path))))



(defvar docker-tramp-docker-options nil "\
List of docker options.")

(custom-autoload 'docker-tramp-docker-options "docker-tramp" t)

(defconst docker-tramp-completion-function-alist '((docker-tramp--parse-running-containers "")) "\
Default list of (FUNCTION FILE) pairs to be examined for docker method.")

(defconst docker-tramp-method "docker" "\
Method to connect docker containers.")

(autoload 'docker-tramp-cleanup "docker-tramp" "\
Cleanup TRAMP cache for docker method." t nil)

(autoload 'docker-tramp-add-method "docker-tramp" "\
Add docker tramp method." nil nil)

(eval-after-load 'tramp '(progn (docker-tramp-add-method) (tramp-set-completion-function docker-tramp-method docker-tramp-completion-function-alist)))

(register-definition-prefixes "docker-tramp" '("docker-tramp-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dart-mode-20220401.0/dart-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/dart-mode-20220401.0/dart-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/dart-mode-20220401.0/dart-mode-autoloads.el") (car load-path))))


 (add-to-list 'auto-mode-alist '("\\.dart\\'" . dart-mode))

(autoload 'dart-mode "dart-mode" "\
Major mode for editing Dart files.

The hook `dart-mode-hook' is run with no args at mode
initialization.

Key bindings:
\\{dart-mode-map}

\(fn)" t nil)

(register-definition-prefixes "dart-mode" '("dart-"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/csv-mode-1.15/csv-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/csv-mode-1.15/csv-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/csv-mode-1.15/csv-mode-autoloads.el") (car load-path))))



(autoload 'csv-mode "csv-mode" "\
Major mode for editing files of comma-separated value type.

CSV mode is derived from `text-mode', and runs `text-mode-hook' before
running `csv-mode-hook'.  It turns `auto-fill-mode' off by default.
CSV mode can be customized by user options in the CSV customization
group.  The separators are specified by the value of `csv-separators'.

CSV mode commands ignore blank lines and comment lines beginning with
the value of `csv-comment-start', which delimit \"paragraphs\".
\"Sexp\" is re-interpreted to mean \"field\", so that `forward-sexp'
\(\\[forward-sexp]), `kill-sexp' (\\[kill-sexp]), etc. all apply to fields.
Standard comment commands apply, such as `comment-dwim' (\\[comment-dwim]).

If `font-lock-mode' is enabled then separators, quoted values and
comment lines are highlighted using respectively `csv-separator-face',
`font-lock-string-face' and `font-lock-comment-face'.

The user interface (UI) for CSV mode commands is similar to that of
the standard commands `sort-fields' and `sort-numeric-fields', except
that if there is no prefix argument then the UI prompts for the field
index or indices.  In `transient-mark-mode' only: if the region is not
set then the UI attempts to set it to include all consecutive CSV
records around point, and prompts for confirmation; if there is no
prefix argument then the UI prompts for it, offering as a default the
index of the field containing point if the region was not set
explicitly.  The region set automatically is delimited by blank lines
and comment lines, and the number of header lines at the beginning of
the region given by the value of `csv-header-lines' are skipped.

Sort order is controlled by `csv-descending'.

CSV mode provides the following specific keyboard key bindings:

\\{csv-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.[Cc][Ss][Vv]\\'" . csv-mode))

(add-to-list 'auto-mode-alist '("\\.tsv\\'" . tsv-mode))

(autoload 'tsv-mode "csv-mode" "\
Major mode for editing files of tab-separated value type.

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "csv-mode" '("csv-" "tsv-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "csv-mode-tests" '("csv-mode-tests--align-fields")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/csharp-mode-20210826.421/csharp-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/csharp-mode-20210826.421/csharp-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/csharp-mode-20210826.421/csharp-mode-autoloads.el") (car load-path))))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "csharp-compilation" '("csharp-")))



(add-to-list 'auto-mode-alist '("\\.cs\\'" . csharp-mode))

(autoload 'csharp-mode "csharp-mode" "\
Major mode for editing Csharp code.

Key bindings:
\\{csharp-mode-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "csharp-mode" '("codedoc-font-lock-" "csharp-")))



(autoload 'csharp-tree-sitter-mode "csharp-tree-sitter" "\
Major mode for editing Csharp code.

Key bindings:
\\{csharp-tree-sitter-mode-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "csharp-tree-sitter" '("csharp-" "tree-sitter-indent-csharp-tree-sitter-scopes")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/consult-0.12/consult-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/consult-0.12/consult-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/consult-0.12/consult-autoloads.el") (car load-path))))



(autoload 'consult-completion-in-region "consult" "\
Use minibuffer completion as the UI for `completion-at-point'.

The function is called with 4 arguments: START END COLLECTION PREDICATE.
The arguments and expected return value are as specified for
`completion-in-region'. Use as a value for `completion-in-region-function'.

The function can be configured via `consult-customize'.

    (consult-customize consult-completion-in-region
                       :completion-styles (basic)
                       :cycle-threshold 3)

These configuration options are supported:

    * :cycle-threshold - Cycling threshold (def: `completion-cycle-threshold')
    * :completion-styles - Use completion styles (def: `completion-styles')
    * :require-match - Require matches when completing (def: nil)
    * :prompt - The prompt string shown in the minibuffer

\(fn START END COLLECTION &optional PREDICATE)" nil nil)

(autoload 'consult-completing-read-multiple "consult" "\
Enhanced replacement for `completing-read-multiple'.
See `completing-read-multiple' for the documentation of the arguments.

\(fn PROMPT TABLE &optional PRED REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)" nil nil)

(autoload 'consult-multi-occur "consult" "\
Improved version of `multi-occur' based on `completing-read-multiple'.

See `multi-occur' for the meaning of the arguments BUFS, REGEXP and NLINES.

\(fn BUFS REGEXP &optional NLINES)" t nil)

(autoload 'consult-outline "consult" "\
Jump to an outline heading, obtained by matching against `outline-regexp'.

This command supports narrowing to a heading level and candidate preview.
The symbol at point is added to the future history." t nil)

(autoload 'consult-mark "consult" "\
Jump to a marker in MARKERS list (defaults to buffer-local `mark-ring').

The command supports preview of the currently selected marker position.
The symbol at point is added to the future history.

\(fn &optional MARKERS)" t nil)

(autoload 'consult-global-mark "consult" "\
Jump to a marker in MARKERS list (defaults to `global-mark-ring').

The command supports preview of the currently selected marker position.
The symbol at point is added to the future history.

\(fn &optional MARKERS)" t nil)

(autoload 'consult-line "consult" "\
Search for a matching line.

Depending on the setting `consult-line-point-placement' the command jumps to
the beginning or the end of the first match on the line or the line beginning.
The default candidate is the non-empty line next to point. This command obeys
narrowing. Optional INITIAL input can be provided. The search starting point is
changed if the START prefix argument is set. The symbol at point and the last
`isearch-string' is added to the future history.

\(fn &optional INITIAL START)" t nil)

(autoload 'consult-line-multi "consult" "\
Search for a matching line in multiple buffers.

By default search across all project buffers. If the prefix argument QUERY is
non-nil, all buffers are searched. Optional INITIAL input can be provided. See
`consult-line' for more information. In order to search a subset of buffers,
QUERY can be set to a plist according to `consult--buffer-query'.

\(fn QUERY &optional INITIAL)" t nil)

(autoload 'consult-keep-lines "consult" "\
Select a subset of the lines in the current buffer with live preview.

The selected lines are kept and the other lines are deleted. When called
interactively, the lines selected are those that match the minibuffer input. In
order to match the inverse of the input, prefix the input with `! '. When
called from elisp, the filtering is performed by a FILTER function. This
command obeys narrowing.

FILTER is the filter function.
INITIAL is the initial input.

\(fn &optional FILTER INITIAL)" t nil)

(autoload 'consult-focus-lines "consult" "\
Hide or show lines using overlays.

The selected lines are shown and the other lines hidden. When called
interactively, the lines selected are those that match the minibuffer input. In
order to match the inverse of the input, prefix the input with `! '. With
optional prefix argument SHOW reveal the hidden lines. Alternatively the
command can be restarted to reveal the lines. When called from elisp, the
filtering is performed by a FILTER function. This command obeys narrowing.

FILTER is the filter function.
INITIAL is the initial input.

\(fn &optional SHOW FILTER INITIAL)" t nil)

(autoload 'consult-goto-line "consult" "\
Read line number and jump to the line with preview.

Jump directly if a line number is given as prefix ARG. The command respects
narrowing and the settings `consult-goto-line-numbers' and
`consult-line-numbers-widen'.

\(fn &optional ARG)" t nil)

(autoload 'consult-recent-file "consult" "\
Find recent file using `completing-read'." t nil)

(autoload 'consult-file-externally "consult" "\
Open FILE externally using the default application of the system.

\(fn FILE)" t nil)

(autoload 'consult-mode-command "consult" "\
Run a command from any of the given MODES.

If no MODES are specified, use currently active major and minor modes.

\(fn &rest MODES)" t nil)

(autoload 'consult-yank-from-kill-ring "consult" "\
Select STRING from the kill ring and insert it.
With prefix ARG, put point at beginning, and mark at end, like `yank' does.

This command behaves like `yank-from-kill-ring' in Emacs 28, which also offers
a `completing-read' interface to the `kill-ring'. Additionally the Consult
version supports preview of the selected string.

\(fn STRING &optional ARG)" t nil)

(autoload 'consult-yank-pop "consult" "\
If there is a recent yank act like `yank-pop'.

Otherwise select string from the kill ring and insert it.
See `yank-pop' for the meaning of ARG.

This command behaves like `yank-pop' in Emacs 28, which also offers a
`completing-read' interface to the `kill-ring'. Additionally the Consult
version supports preview of the selected string.

\(fn &optional ARG)" t nil)

(autoload 'consult-yank-replace "consult" "\
Select STRING from the kill ring.

If there was no recent yank, insert the string.
Otherwise replace the just-yanked string with the selected string.

There exists no equivalent of this command in Emacs 28.

\(fn STRING)" t nil)

(autoload 'consult-bookmark "consult" "\
If bookmark NAME exists, open it, otherwise create a new bookmark with NAME.

The command supports preview of file bookmarks and narrowing. See the
variable `consult-bookmark-narrow' for the narrowing configuration.

\(fn NAME)" t nil)

(autoload 'consult-apropos "consult" "\
Select pattern and call `apropos'.

The default value of the completion is the symbol at point." t nil)

(autoload 'consult-complex-command "consult" "\
Select and evaluate command from the command history.

This command can act as a drop-in replacement for `repeat-complex-command'." t nil)

(autoload 'consult-history "consult" "\
Insert string from HISTORY of current buffer.

In order to select from a specific HISTORY, pass the history variable as argument.

\(fn &optional HISTORY)" t nil)

(autoload 'consult-isearch "consult" "\
Read a search string with completion from history.

This replaces the current search string if Isearch is active, and
starts a new Isearch session otherwise." t nil)

(autoload 'consult-minor-mode-menu "consult" "\
Enable or disable minor mode.

This is an alternative to `minor-mode-menu-from-indicator'." t nil)

(autoload 'consult-theme "consult" "\
Disable current themes and enable THEME from `consult-themes'.

The command supports previewing the currently selected theme.

\(fn THEME)" t nil)

(autoload 'consult-buffer "consult" "\
Enhanced `switch-to-buffer' command with support for virtual buffers.

The command supports recent files, bookmarks, views and project files as virtual
buffers. Buffers are previewed. Furthermore narrowing to buffers (b), files (f),
bookmarks (m) and project files (p) is supported via the corresponding keys. In
order to determine the project-specific files and buffers, the
`consult-project-root-function' is used. See `consult-buffer-sources' and
`consult--multi' for the configuration of the virtual buffer sources." t nil)

(autoload 'consult-buffer-other-window "consult" "\
Variant of `consult-buffer' which opens in other window." t nil)

(autoload 'consult-buffer-other-frame "consult" "\
Variant of `consult-buffer' which opens in other frame." t nil)

(autoload 'consult-kmacro "consult" "\
Run a chosen keyboard macro.

With prefix ARG, run the macro that many times.
Macros containing mouse clicks are omitted.

\(fn ARG)" t nil)

(autoload 'consult-grep "consult" "\
Search for regexp with grep in DIR with INITIAL input.

The input string is split, the first part of the string is passed to
the asynchronous grep process and the second part of the string is
passed to the completion-style filtering. The input string is split at
a punctuation character, which is given as the first character of the
input string. The format is similar to Perl-style regular expressions,
e.g., /regexp/. Furthermore command line options can be passed to
grep, specified behind --.

Example: #async-regexp -- grep-opts#filter-string

The symbol at point is added to the future history. If `consult-grep'
is called interactively with a prefix argument, the user can specify
the directory to search in. By default the project directory is used
if `consult-project-root-function' is defined and returns non-nil.
Otherwise the `default-directory' is searched.

\(fn &optional DIR INITIAL)" t nil)

(autoload 'consult-git-grep "consult" "\
Search for regexp with grep in DIR with INITIAL input.

See `consult-grep' for more details.

\(fn &optional DIR INITIAL)" t nil)

(autoload 'consult-ripgrep "consult" "\
Search for regexp with rg in DIR with INITIAL input.

See `consult-grep' for more details.

\(fn &optional DIR INITIAL)" t nil)

(autoload 'consult-find "consult" "\
Search for regexp with find in DIR with INITIAL input.

The find process is started asynchronously, similar to `consult-grep'.
See `consult-grep' for more details regarding the asynchronous search.

\(fn &optional DIR INITIAL)" t nil)

(autoload 'consult-locate "consult" "\
Search for regexp with locate with INITIAL input.

The locate process is started asynchronously, similar to `consult-grep'.
See `consult-grep' for more details regarding the asynchronous search.

\(fn &optional INITIAL)" t nil)

(autoload 'consult-man "consult" "\
Search for regexp with man with INITIAL input.

The man process is started asynchronously, similar to `consult-grep'.
See `consult-grep' for more details regarding the asynchronous search.

\(fn &optional INITIAL)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult" '("consult-")))



(autoload 'consult-compile-error "consult-compile" "\
Jump to a compilation error in the current buffer.

This command collects entries from compilation buffers and grep
buffers related to the current buffer.  The command supports
preview of the currently selected error." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-compile" '("consult-compile--")))



(autoload 'consult-flymake "consult-flymake" "\
Jump to Flymake diagnostic." t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-flymake" '("consult-flymake--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-icomplete" '("consult-icomplete--refresh")))



(autoload 'consult-imenu "consult-imenu" "\
Select item from flattened `imenu' using `completing-read' with preview.

The command supports preview and narrowing. See the variable
`consult-imenu-config', which configures the narrowing.
The symbol at point is added to the future history.

See also `consult-imenu-multi'." t nil)

(autoload 'consult-imenu-multi "consult-imenu" "\
Select item from the imenus of all buffers from the same project.

In order to determine the buffers belonging to the same project, the
`consult-project-root-function' is used. Only the buffers with the
same major mode as the current buffer are used. See also
`consult-imenu' for more details. In order to search a subset of buffers,
QUERY can be set to a plist according to `consult--buffer-query'.

\(fn &optional QUERY)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-imenu" '("consult-imenu-")))



(autoload 'consult-org-heading "consult-org" "\
Jump to an Org heading.

MATCH and SCOPE are as in `org-map-entries' and determine which
entries are offered.  By default, all entries of the current
buffer are offered.

\(fn &optional MATCH SCOPE)" t nil)

(autoload 'consult-org-agenda "consult-org" "\
Jump to an Org agenda heading.

By default, all agenda entries are offered. MATCH is as in
`org-map-entries' and can used to refine this.

\(fn &optional MATCH)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-org" '("consult-org--")))



(autoload 'consult-register-window "consult-register" "\
Enhanced drop-in replacement for `register-preview'.

BUFFER is the window buffer.
SHOW-EMPTY must be t if the window should be shown for an empty register list.

\(fn BUFFER &optional SHOW-EMPTY)" nil nil)

(autoload 'consult-register-format "consult-register" "\
Enhanced preview of register REG.

This function can be used as `register-preview-function'.

\(fn REG)" nil nil)

(autoload 'consult-register "consult-register" "\
Load register and either jump to location or insert the stored text.

This command is useful to search the register contents. For quick access to
registers it is still recommended to use the register functions
`consult-register-load' and `consult-register-store' or the built-in built-in
register access functions. The command supports narrowing, see
`consult-register-narrow'. Marker positions are previewed. See
`jump-to-register' and `insert-register' for the meaning of prefix ARG.

\(fn &optional ARG)" t nil)

(autoload 'consult-register-load "consult-register" "\
Do what I mean with a REG.

For a window configuration, restore it. For a number or text, insert it. For a
location, jump to it. See `jump-to-register' and `insert-register' for the
meaning of prefix ARG.

\(fn REG &optional ARG)" t nil)

(autoload 'consult-register-store "consult-register" "\
Store register dependent on current context, showing an action menu.

With an active region, store/append/prepend the contents, optionally deleting
the region when a prefix ARG is given. With a numeric prefix ARG, store/add the
number. Otherwise store point, frameset, window or kmacro.

\(fn ARG)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-register" '("consult-register-")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-selectrum" '("consult-selectrum--")))



(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-vertico" '("consult-vertico--")))



(autoload 'consult-xref "consult-xref" "\
Show xrefs with preview in the minibuffer.

This function can be used for `xref-show-xrefs-function'.
See `xref-show-xrefs-function' for the description of the
FETCHER and ALIST arguments.

\(fn FETCHER &optional ALIST)" nil nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "consult-xref" '("consult-xref--")))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/clojure-mode-20220729.2246/clojure-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/clojure-mode-20220729.2246/clojure-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/clojure-mode-20220729.2246/clojure-mode-autoloads.el") (car load-path))))



(autoload 'clojure-mode "clojure-mode" "\
Major mode for editing Clojure code.

\\{clojure-mode-map}

\(fn)" t nil)

(autoload 'clojure-unwind "clojure-mode" "\
Unwind thread at point or above point by N levels.
With universal argument \\[universal-argument], fully unwind thread.

\(fn &optional N)" t nil)

(autoload 'clojure-unwind-all "clojure-mode" "\
Fully unwind thread at point or above point." t nil)

(autoload 'clojure-thread "clojure-mode" "\
Thread by one more level an existing threading macro." t nil)

(autoload 'clojure-thread-first-all "clojure-mode" "\
Fully thread the form at point using ->.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-thread-last-all "clojure-mode" "\
Fully thread the form at point using ->>.

When BUT-LAST is non-nil, the last expression is not threaded.
Default value is `clojure-thread-all-but-last'.

\(fn BUT-LAST)" t nil)

(autoload 'clojure-cycle-privacy "clojure-mode" "\
Make public the current private def, or vice-versa.
See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-privacy" t nil)

(autoload 'clojure-convert-collection-to-list "clojure-mode" "\
Convert collection at (point) to list." t nil)

(autoload 'clojure-convert-collection-to-quoted-list "clojure-mode" "\
Convert collection at (point) to quoted list." t nil)

(autoload 'clojure-convert-collection-to-map "clojure-mode" "\
Convert collection at (point) to map." t nil)

(autoload 'clojure-convert-collection-to-vector "clojure-mode" "\
Convert collection at (point) to vector." t nil)

(autoload 'clojure-convert-collection-to-set "clojure-mode" "\
Convert collection at (point) to set." t nil)

(autoload 'clojure-cycle-if "clojure-mode" "\
Change a surrounding if to if-not, or vice-versa.

See: https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-cycle-if" t nil)

(autoload 'clojure-cycle-when "clojure-mode" "\
Change a surrounding when to when-not, or vice-versa." t nil)

(autoload 'clojure-let-backward-slurp-sexp "clojure-mode" "\
Slurp the s-expression before the let form into the let form.
With a numeric prefix argument slurp the previous N s-expressions
into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-let-forward-slurp-sexp "clojure-mode" "\
Slurp the next s-expression after the let form into the let form.
With a numeric prefix argument slurp the next N s-expressions
into the let form.

\(fn &optional N)" t nil)

(autoload 'clojure-introduce-let "clojure-mode" "\
Create a let form, binding the form at point.
With a numeric prefix argument the let is introduced N lists up.

\(fn &optional N)" t nil)

(autoload 'clojure-move-to-let "clojure-mode" "\
Move the form at point to a binding in the nearest let." t nil)

(autoload 'clojure-rename-ns-alias "clojure-mode" "\
Rename a namespace alias.
If a region is active, only pick up and rename aliases within the region." t nil)

(autoload 'clojure-add-arity "clojure-mode" "\
Add an arity to a function." t nil)

(autoload 'clojurescript-mode "clojure-mode" "\
Major mode for editing ClojureScript code.

\\{clojurescript-mode-map}

\(fn)" t nil)

(autoload 'clojurec-mode "clojure-mode" "\
Major mode for editing ClojureC code.

\\{clojurec-mode-map}

\(fn)" t nil)

(add-to-list 'auto-mode-alist '("\\.\\(clj\\|cljd\\|dtm\\|edn\\)\\'" . clojure-mode))

(add-to-list 'auto-mode-alist '("\\.cljc\\'" . clojurec-mode))

(add-to-list 'auto-mode-alist '("\\.cljs\\'" . clojurescript-mode))

(add-to-list 'auto-mode-alist '("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode))

(add-to-list 'interpreter-mode-alist '("bb" . clojure-mode))

(register-definition-prefixes "clojure-mode" '("add-custom-clojure-indents" "clojure" "define-clojure-indent" "put-clojure-indent"))


)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/cider-20220810.1514/cider-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/cider-20220810.1514/cider-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/cider-20220810.1514/cider-autoloads.el") (car load-path))))



(autoload 'cider-version "cider" "\
Display CIDER's version." t nil)
 (autoload 'cider-start-map "cider" "CIDER jack-in and connect keymap." t 'keymap)

(autoload 'cider-jack-in-clj "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir and :jack-in-cmd.
With the prefix argument, allow editing of the jack in command; with a
double prefix prompt for all these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-cljs "cider" "\
Start an nREPL server for the current project and connect to it.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
allow editing of the jack in command; with a double prefix prompt for all
these parameters.

\(fn PARAMS)" t nil)

(autoload 'cider-jack-in-clj&cljs "cider" "\
Start an nREPL server and connect with clj and cljs REPLs.
PARAMS is a plist optionally containing :project-dir, :jack-in-cmd and
:cljs-repl-type (e.g. Node, Figwheel, etc).  With the prefix argument,
allow for editing of the jack in command; with a double prefix prompt for
all these parameters.  When SOFT-CLJS-START is non-nil, start cljs REPL
only when the ClojureScript dependencies are met.

\(fn &optional PARAMS SOFT-CLJS-START)" t nil)

(autoload 'cider-connect-sibling-clj "cider" "\
Create a Clojure REPL with the same server as OTHER-REPL.
PARAMS is for consistency with other connection commands and is currently
ignored.  OTHER-REPL defaults to `cider-current-repl' and in programs can
also be a server buffer, in which case a new session with a REPL for that
server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-sibling-cljs "cider" "\
Create a ClojureScript REPL with the same server as OTHER-REPL.
PARAMS is a plist optionally containing :cljs-repl-type (e.g. Node,
Figwheel, etc).  All other parameters are inferred from the OTHER-REPL.
OTHER-REPL defaults to `cider-current-repl' but in programs can also be a
server buffer, in which case a new session for that server is created.

\(fn PARAMS &optional OTHER-REPL)" t nil)

(autoload 'cider-connect-clj "cider" "\
Initialize a Clojure connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port and :project-dir.  On
prefix argument, prompt for all the parameters.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-cljs "cider" "\
Initialize a ClojureScript connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  On prefix, prompt for all the
parameters regardless of their supplied or default values.

\(fn &optional PARAMS)" t nil)

(autoload 'cider-connect-clj&cljs "cider" "\
Initialize a Clojure and ClojureScript connection to an nREPL server.
PARAMS is a plist optionally containing :host, :port, :project-dir and
:cljs-repl-type (e.g. Node, Figwheel, etc).  When SOFT-CLJS-START is
non-nil, don't start if ClojureScript requirements are not met.

\(fn PARAMS &optional SOFT-CLJS-START)" t nil)

(autoload 'cider "cider" "\
Start a connection of any type interactively." t nil)

(defalias 'cider-jack-in #'cider-jack-in-clj)

(defalias 'cider-connect #'cider-connect-clj)

(with-eval-after-load 'clojure-mode (define-key clojure-mode-map (kbd "C-c M-x") #'cider) (define-key clojure-mode-map (kbd "C-c M-j") #'cider-jack-in-clj) (define-key clojure-mode-map (kbd "C-c M-J") #'cider-jack-in-cljs) (define-key clojure-mode-map (kbd "C-c M-c") #'cider-connect-clj) (define-key clojure-mode-map (kbd "C-c M-C") #'cider-connect-cljs) (define-key clojure-mode-map (kbd "C-c C-x") 'cider-start-map) (define-key clojure-mode-map (kbd "C-c C-s") 'sesman-map) (require 'sesman) (sesman-install-menu clojure-mode-map) (add-hook 'clojure-mode-hook (lambda nil (setq-local sesman-system 'CIDER))))

(register-definition-prefixes "cider" '("cider-"))



(autoload 'cider-apropos "cider-apropos" "\
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation "cider-apropos" "\
Shortcut for (cider-apropos <query> nil t)." t nil)

(autoload 'cider-apropos-select "cider-apropos" "\
Similar to `cider-apropos', but presents the results in a completing read.
Show all symbols whose names match QUERY, a regular expression.
QUERY can also be a list of space-separated words (e.g. take while) which
will be converted to a regular expression (like take.+while) automatically
behind the scenes.  The search may be limited to the namespace NS, and may
optionally search doc strings (based on DOCS-P), include private vars
\(based on PRIVATES-P), and be case-sensitive (based on CASE-SENSITIVE-P).

\(fn QUERY &optional NS DOCS-P PRIVATES-P CASE-SENSITIVE-P)" t nil)

(autoload 'cider-apropos-documentation-select "cider-apropos" "\
Shortcut for (cider-apropos-select <query> nil t)." t nil)

(register-definition-prefixes "cider-apropos" '("apropos-special-form" "cider-"))



(autoload 'cider-browse-ns "cider-browse-ns" "\
List all NAMESPACE's vars in BUFFER.

\(fn NAMESPACE)" t nil)

(autoload 'cider-browse-ns-all "cider-browse-ns" "\
List all loaded namespaces in BUFFER." t nil)

(register-definition-prefixes "cider-browse-ns" '("cider-browse-ns-"))



(autoload 'cider-browse-spec "cider-browse-spec" "\
Browse SPEC definition.

\(fn SPEC)" t nil)

(autoload 'cider-browse-spec-all "cider-browse-spec" "\
Open list of specs in a popup buffer.

With a prefix argument ARG, prompts for a regexp to filter specs.
No filter applied if the regexp is the empty string.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "cider-browse-spec" '("cider-"))



(autoload 'cider-cheatsheet "cider-cheatsheet" "\
Navigate `cider-cheatsheet-hierarchy' with `completing-read'.

When you make it to a Clojure var its doc buffer gets displayed." t nil)

(register-definition-prefixes "cider-cheatsheet" '("cider-cheatsheet-"))



(autoload 'cider-classpath "cider-classpath" "\
List all classpath entries." t nil)

(autoload 'cider-open-classpath-entry "cider-classpath" "\
Open a classpath entry." t nil)

(register-definition-prefixes "cider-classpath" '("cider-classpath-"))



(register-definition-prefixes "cider-client" '("cider-"))



(autoload 'cider-clojuredocs-web "cider-clojuredocs" "\
Open ClojureDocs documentation in the default web browser.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(autoload 'cider-clojuredocs-refresh-cache "cider-clojuredocs" "\
Refresh the ClojureDocs cache." t nil)

(autoload 'cider-clojuredocs "cider-clojuredocs" "\
Open ClojureDocs documentation in a popup buffer.

Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "cider-clojuredocs" '("cider-"))



(register-definition-prefixes "cider-common" '("cider-"))



(register-definition-prefixes "cider-completion" '("cider-"))



(defvar cider-merge-sessions nil "\
Controls session combination behaviour.

Symbol `host' combines all sessions of a project associated with the same host.
Symbol `project' combines all sessions of a project.

All other values do not combine any sessions.")

(custom-autoload 'cider-merge-sessions "cider-connection" t)

(put 'cider-merge-sessions 'safe-local-variable #'symbolp)

(register-definition-prefixes "cider-connection" '("cider-"))



(autoload 'cider-debug-defun-at-point "cider-debug" "\
Instrument the \"top-level\" expression at point.
If it is a defn, dispatch the instrumented definition.  Otherwise,
immediately evaluate the instrumented expression.

While debugged code is being evaluated, the user is taken through the
source code and displayed the value of various expressions.  At each step,
a number of keys will be prompted to the user." t nil)

(register-definition-prefixes "cider-debug" '("cider-"))



(register-definition-prefixes "cider-doc" '("cider-"))



(register-definition-prefixes "cider-eldoc" '("cider-"))



(register-definition-prefixes "cider-eval" '("cider-"))



(autoload 'cider-find-var "cider-find" "\
Find definition for VAR at LINE.
Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG VAR LINE)" t nil)

(autoload 'cider-find-dwim-at-mouse "cider-find" "\
Find and display variable or resource at mouse EVENT.

\(fn EVENT)" t nil)

(autoload 'cider-find-dwim "cider-find" "\
Find and display the SYMBOL-FILE at point.
SYMBOL-FILE could be a var or a resource.  If thing at point is empty then
show Dired on project.  If var is not found, try to jump to resource of the
same name.  When called interactively, a prompt is given according to the
variable `cider-prompt-for-symbol'.  A single or double prefix argument
inverts the meaning.  A prefix of `-' or a double prefix argument causes
the results to be displayed in a different window.  A default value of thing
at point is given when prompted.

\(fn SYMBOL-FILE)" t nil)

(autoload 'cider-find-resource "cider-find" "\
Find the resource at PATH.
Prompt for input as indicated by the variable `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix argument of `-` or a double prefix
argument causes the results to be displayed in other window.  The default
value is thing at point.

\(fn PATH)" t nil)

(autoload 'cider-find-ns "cider-find" "\
Find the file containing NS.
A prefix ARG of `-` or a double prefix argument causes
the results to be displayed in a different window.

\(fn &optional ARG NS)" t nil)

(autoload 'cider-find-keyword "cider-find" "\
Find the namespace of the keyword at point and its first occurrence there.

For instance - if the keyword at point is \":cider.demo/keyword\", this command
would find the namespace \"cider.demo\" and afterwards find the first mention
of \"::keyword\" there.

Prompt according to prefix ARG and `cider-prompt-for-symbol'.
A single or double prefix argument inverts the meaning of
`cider-prompt-for-symbol'.  A prefix of `-` or a double prefix argument causes
the results to be displayed in a different window.  The default value is
thing at point.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "cider-find" '("cider-"))



(autoload 'cider-format-region "cider-format" "\
Format the Clojure code in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-defun "cider-format" "\
Format the code in the current defun." t nil)

(autoload 'cider-format-buffer "cider-format" "\
Format the Clojure code in the current buffer." t nil)

(autoload 'cider-format-edn-buffer "cider-format" "\
Format the EDN data in the current buffer." t nil)

(autoload 'cider-format-edn-region "cider-format" "\
Format the EDN data in the current region.
START and END represent the region's boundaries.

\(fn START END)" t nil)

(autoload 'cider-format-edn-last-sexp "cider-format" "\
Format the EDN data of the last sexp." t nil)

(register-definition-prefixes "cider-format" '("cider--format-"))



(autoload 'cider-inspect-last-sexp "cider-inspector" "\
Inspect the result of the the expression preceding point." t nil)

(autoload 'cider-inspect-defun-at-point "cider-inspector" "\
Inspect the result of the \"top-level\" expression at point." t nil)

(autoload 'cider-inspect-last-result "cider-inspector" "\
Inspect the most recent eval result." t nil)

(autoload 'cider-inspect "cider-inspector" "\
Inspect the result of the preceding sexp.

With a prefix argument ARG it inspects the result of the \"top-level\" form.
With a second prefix argument it prompts for an expression to eval and inspect.

\(fn &optional ARG)" t nil)

(autoload 'cider-inspect-expr "cider-inspector" "\
Evaluate EXPR in NS and inspect its value.
Interactively, EXPR is read from the minibuffer, and NS the
current buffer's namespace.

\(fn EXPR NS)" t nil)

(register-definition-prefixes "cider-inspector" '("cider-"))



(register-definition-prefixes "cider-jar" '("cider-jar-"))



(autoload 'cider-macroexpand-1 "cider-macroexpansion" "\
Invoke \\=`macroexpand-1\\=` on the expression preceding point.
If invoked with a PREFIX argument, use \\=`macroexpand\\=` instead of
\\=`macroexpand-1\\=`.

\(fn &optional PREFIX)" t nil)

(autoload 'cider-macroexpand-all "cider-macroexpansion" "\
Invoke \\=`macroexpand-all\\=` on the expression preceding point." t nil)

(register-definition-prefixes "cider-macroexpansion" '("cider-"))



(defvar cider-mode-line '(:eval (format " cider[%s]" (cider--modeline-info))) "\
Mode line lighter for cider mode.

The value of this variable is a mode line template as in
`mode-line-format'.  See Info Node `(elisp)Mode Line Format' for details
about mode line templates.

Customize this variable to change how cider mode displays its status in the
mode line.  The default value displays the current connection.  Set this
variable to nil to disable the mode line entirely.")

(custom-autoload 'cider-mode-line "cider-mode" t)

(with-eval-after-load 'clojure-mode (easy-menu-define cider-clojure-mode-menu-open clojure-mode-map "Menu for Clojure mode.\n  This is displayed in `clojure-mode' buffers, if `cider-mode' is not active." `("CIDER" :visible (not cider-mode) ["Start a Clojure REPL" cider-jack-in-clj :help "Starts an nREPL server and connects a Clojure REPL to it."] ["Connect to a Clojure REPL" cider-connect-clj :help "Connects to a REPL that's already running."] ["Start a ClojureScript REPL" cider-jack-in-cljs :help "Starts an nREPL server and connects a ClojureScript REPL to it."] ["Connect to a ClojureScript REPL" cider-connect-cljs :help "Connects to a ClojureScript REPL that's already running."] ["Start a Clojure REPL, and a ClojureScript REPL" cider-jack-in-clj&cljs :help "Starts an nREPL server, connects a Clojure REPL to it, and then a ClojureScript REPL."] "--" ["View user manual" cider-view-manual])))

(autoload 'cider-mode "cider-mode" "\
Minor mode for REPL interaction from a Clojure buffer.

This is a minor mode.  If called interactively, toggle the `Cider
mode' mode.  If the prefix argument is positive, enable the mode,
and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `cider-mode'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

\\{cider-mode-map}

\(fn &optional ARG)" t nil)

(register-definition-prefixes "cider-mode" '("cider-"))



(autoload 'cider-ns-reload "cider-ns" "\
Send a (require 'ns :reload) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload forces loading of all the
identified libs even if they are already loaded\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-reload-all "cider-ns" "\
Send a (require 'ns :reload-all) to the REPL.

With an argument PROMPT, it prompts for a namespace name.  This is the
Clojure out of the box reloading experience and does not rely on
org.clojure/tools.namespace.  See Commentary of this file for a longer list
of differences.  From the Clojure doc: \":reload-all implies :reload and
also forces loading of all libs that the identified libs directly or
indirectly load via require\".

\(fn &optional PROMPT)" t nil)

(autoload 'cider-ns-refresh "cider-ns" "\
Reload modified and unloaded namespaces on the classpath.

With a single prefix argument, or if MODE is `refresh-all', reload all
namespaces on the classpath unconditionally.

With a double prefix argument, or if MODE is `clear', clear the state of
the namespace tracker before reloading.  This is useful for recovering from
some classes of error (for example, those caused by circular dependencies)
that a normal reload would not otherwise recover from.  The trade-off of
clearing is that stale code from any deleted files may not be completely
unloaded.

With a negative prefix argument, or if MODE is `inhibit-fns', prevent any
refresh functions (defined in `cider-ns-refresh-before-fn' and
`cider-ns-refresh-after-fn') from being invoked.

\(fn &optional MODE)" t nil)

(register-definition-prefixes "cider-ns" '("cider-ns-"))



(register-definition-prefixes "cider-overlays" '("cider-"))



(register-definition-prefixes "cider-popup" '("cider-"))



(autoload 'cider-profile-samples "cider-profile" "\
Displays current max-sample-count.
If optional QUERY is specified, set max-sample-count and display new value.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-var-profiled-p "cider-profile" "\
Displays the profiling status of var under point.
Prompts for var if none under point or QUERY is present.

\(fn QUERY)" t nil)

(autoload 'cider-profile-ns-toggle "cider-profile" "\
Toggle profiling for the ns associated with optional QUERY.

If optional argument QUERY is non-nil, prompt for ns.  Otherwise use
current ns.

\(fn &optional QUERY)" t nil)

(autoload 'cider-profile-toggle "cider-profile" "\
Toggle profiling for the given QUERY.
Defaults to the symbol at point.
With prefix arg or no symbol at point, prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-summary "cider-profile" "\
Display a summary of currently collected profile data." t nil)

(autoload 'cider-profile-var-summary "cider-profile" "\
Display profile data for var under point QUERY.
Defaults to the symbol at point.  With prefix arg or no symbol at point,
prompts for a var.

\(fn QUERY)" t nil)

(autoload 'cider-profile-clear "cider-profile" "\
Clear any collected profile data." t nil)

(register-definition-prefixes "cider-profile" '("cider-profile-"))



(register-definition-prefixes "cider-repl" '("cider-"))



(autoload 'cider-repl-history "cider-repl-history" "\
Display items in the CIDER command history in another buffer." t nil)

(register-definition-prefixes "cider-repl-history" '("cider-repl-history-"))



(register-definition-prefixes "cider-resolve" '("cider-resolve-"))



(autoload 'cider-scratch "cider-scratch" "\
Go to the scratch buffer named `cider-scratch-buffer-name'." t nil)

(register-definition-prefixes "cider-scratch" '("cider-"))



(autoload 'cider-selector "cider-selector" "\
Select a new buffer by type, indicated by a single character.
The user is prompted for a single character indicating the method by
which to choose a new buffer.  The `?' character describes the
available methods.  OTHER-WINDOW provides an optional target.
See `def-cider-selector-method' for defining new methods.

\(fn &optional OTHER-WINDOW)" t nil)

(register-definition-prefixes "cider-selector" '("??" "?c" "?d" "?e" "?m" "?p" "?q" "?r" "?s" "?x" "cider-selector-" "def-cider-selector-method"))



(register-definition-prefixes "cider-stacktrace" '("cider-"))



(defvar cider-auto-test-mode nil "\
Non-nil if Cider-Auto-Test mode is enabled.
See the `cider-auto-test-mode' command
for a description of this minor mode.
Setting this variable directly does not take effect;
either customize it (see the info node `Easy Customization')
or call the function `cider-auto-test-mode'.")

(custom-autoload 'cider-auto-test-mode "cider-test" nil)

(autoload 'cider-auto-test-mode "cider-test" "\
Toggle automatic testing of Clojure files.

This is a minor mode.  If called interactively, toggle the
`Cider-Auto-Test mode' mode.  If the prefix argument is positive,
enable the mode, and if it is zero or negative, disable the mode.

If called from Lisp, toggle the mode if ARG is `toggle'.  Enable
the mode if ARG is nil, omitted, or is a positive number.
Disable the mode if ARG is a negative number.

To check whether the minor mode is enabled in the current buffer,
evaluate `(default-value \\='cider-auto-test-mode)'.

The mode's hook is called both when the mode is enabled and when
it is disabled.

When enabled this reruns tests every time a Clojure file is loaded.
Only runs tests corresponding to the loaded file's namespace and does
nothing if no tests are defined or if the file failed to load.

\(fn &optional ARG)" t nil)

(register-definition-prefixes "cider-test" '("cider-"))



(autoload 'cider-toggle-trace-var "cider-tracing" "\
Toggle var tracing.
Prompts for the symbol to use, or uses the symbol at point, depending on
the value of `cider-prompt-for-symbol'.  With prefix arg ARG, does the
opposite of what that option dictates.

\(fn ARG)" t nil)

(autoload 'cider-toggle-trace-ns "cider-tracing" "\
Toggle ns tracing.
Defaults to the current ns.  With prefix arg QUERY, prompts for a ns.

\(fn QUERY)" t nil)

(register-definition-prefixes "cider-tracing" '("cider-"))



(autoload 'cider-view-manual "cider-util" "\
View the manual in your default browser." t nil)

(register-definition-prefixes "cider-util" '("cider-"))



(autoload 'cider-xref-fn-refs "cider-xref" "\
Show all functions that reference the var matching NS and SYMBOL.

\(fn &optional NS SYMBOL)" t nil)

(autoload 'cider-xref-fn-deps "cider-xref" "\
Show all functions referenced by the var matching NS and SYMBOL.

\(fn &optional NS SYMBOL)" t nil)

(autoload 'cider-xref-fn-refs-select "cider-xref" "\
Displays the references for NS and SYMBOL using completing read.

\(fn &optional NS SYMBOL)" t nil)

(autoload 'cider-xref-fn-deps-select "cider-xref" "\
Displays the function dependencies for  NS and SYMBOL using completing read.

\(fn &optional NS SYMBOL)" t nil)

(register-definition-prefixes "cider-xref" '("cider-"))



(register-definition-prefixes "nrepl-client" '("cider-enlighten-mode" "emacs-bug-46284/when-27.1-windows-nt" "nrepl-"))



(register-definition-prefixes "nrepl-dict" '("nrepl-"))




)
(let ((load-true-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/ahk-mode-20200412.1832/ahk-mode-autoloads.el")(load-file-name "c:/Users/Jacob Leeming/.emacs.d/elpa/ahk-mode-20200412.1832/ahk-mode-autoloads.el"))

(add-to-list 'load-path (directory-file-name
                         (or (file-name-directory "c:/Users/Jacob Leeming/.emacs.d/elpa/ahk-mode-20200412.1832/ahk-mode-autoloads.el") (car load-path))))



(add-to-list 'auto-mode-alist '("\\.ahk\\'" . ahk-mode))

(autoload 'ahk-mode "ahk-mode" "\
Major mode for editing AutoHotkey script (AHK).

The hook functions in `ahk-mode-hook' are run after mode initialization.

Key Bindings
\\{ahk-mode-map}

\(fn)" t nil)

(if (fboundp 'register-definition-prefixes) (register-definition-prefixes "ahk-mode" '("ac-source-" "ahk-")))


)
(setq package-activated-list
      (append
       '(yaml-mode xah-fly-keys vertico typescript-mode tsc tree-sitter tree-sitter-langs tree-sitter-indent spinner sml-mode sesman s restclient restart-emacs pos-tip racket-mode queue purescript-mode powershell parseclj parseedn orderless markdown-mode marginalia lv kotlin-mode json-snatcher json-reformat json-mode inf-ruby dash ht go-mode gdscript-mode fsharp-mode feature-mode f expand-region eglot eglot-fsharp dotenv-mode dockerfile-mode docker-tramp dart-mode csv-mode csharp-mode consult clojure-mode cider ahk-mode)
       package-activated-list))
(progn
  (require 'info)
  (info-initialize)
  (setq Info-directory-list
        (append
         '("c:/Users/Jacob Leeming/.emacs.d/elpa/consult-0.12" "c:/Users/Jacob Leeming/.emacs.d/elpa/dash-20210826.1149" "c:/Users/Jacob Leeming/.emacs.d/elpa/orderless-20210603.1335" "c:/Users/Jacob Leeming/.emacs.d/elpa/purescript-mode-20210109.244" "c:/Users/Jacob Leeming/.emacs.d/elpa/racket-mode-20210831.2045" "c:/Users/Jacob Leeming/.emacs.d/elpa/vertico-0.21")
         Info-directory-list)))

;; Local Variables:
;; version-control: never
;; no-update-autoloads: t
;; End:
